{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"teamleader-sdk","text":"<p>Python SDK for the Teamleader Focus API.</p> <ul> <li>Generated CRUD layer from the official OpenAPI spec (<code>@teamleader/focus-api-specification</code>)</li> <li>Curated model classes with computed properties and full type hints</li> <li>Optional Django integration: <code>DatabaseTokenBackend</code>, <code>teamleader_setup</code> management command</li> <li>Framework-agnostic core usable from FastAPI, Celery, scripts, etc.</li> <li>Python \u2265 3.10 \u00b7 <code>requests</code> \u00b7 no Pydantic / attrs</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"Dependency Version Python \u2265 3.10 requests \u2265 2.28 Django (optional) \u2265 4.2"},{"location":"#installation","title":"Installation","text":"<pre><code># Core only (non-Django projects, scripts, Celery workers)\npip install teamleader-sdk\n\n# With Django integration\npip install teamleader-sdk[django]\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"DjangoStandalone <pre><code># After running: python manage.py teamleader_setup\nfrom teamleader.django import get_client\n\nclient = get_client()\nfor deal in client.deals.iterate():\n    print(deal.title, deal.is_open)\n</code></pre> <pre><code>from datetime import datetime, timezone\nfrom teamleader import TeamleaderClient, OAuth2Handler, MemoryTokenBackend, Token\n\nbackend = MemoryTokenBackend()\nbackend.save(Token(\n    access_token=\"&lt;access-token&gt;\",\n    refresh_token=\"&lt;refresh-token&gt;\",\n    expires_at=datetime(2025, 12, 31, tzinfo=timezone.utc),\n))\nhandler = OAuth2Handler(\n    client_id=\"your-client-id\",\n    client_secret=\"your-client-secret\",\n    redirect_uri=\"http://localhost:9999/callback\",\n    token_backend=backend,\n)\nclient = TeamleaderClient(handler)\ncontact = client.contacts.get(\"cde0bc5f-8602-4e12-b5d3-f03436b54c0d\")\nprint(contact.full_name, contact.primary_email)\n</code></pre>"},{"location":"#whats-in-the-box","title":"What's in the box","text":"Module Contents <code>teamleader.models</code> <code>Contact</code>, <code>Company</code>, <code>Deal</code>, <code>Invoice</code>, <code>Quotation</code> + common sub-models <code>teamleader.resources</code> <code>CrudResource</code>, <code>Page</code>, <code>ContactsResource</code>, <code>CompaniesResource</code>, <code>DealsResource</code>, <code>InvoicesResource</code>, <code>QuotationsResource</code> <code>teamleader.auth</code> <code>Token</code>, <code>TokenBackend</code>, <code>MemoryTokenBackend</code>, <code>OAuth2Handler</code> <code>teamleader.client</code> <code>TeamleaderClient</code> <code>teamleader.exceptions</code> 9-class exception hierarchy <code>teamleader._generated</code> 290 endpoints, 483 base models, 23 enums \u2014 auto-generated from spec v1.112.0 <code>teamleader.django</code> <code>DatabaseTokenBackend</code>, <code>TeamleaderToken</code>, <code>teamleader_setup</code> command"},{"location":"codegen/","title":"Codegen \u2014 Updating the Generated Layer","text":"<p>The SDK is partially generated from the Teamleader Focus OpenAPI spec published on npm as <code>@teamleader/focus-api-specification</code>.  The committed snapshot at <code>codegen/spec/api.yaml</code> (currently v1.112.0) serves as the canonical baseline for diffing against future spec versions.</p>"},{"location":"codegen/#what-is-generated","title":"What is generated","text":"File Contents Safe to overwrite? <code>teamleader/_generated/enums.py</code> 23 <code>str, Enum</code> subclasses \u2705 Yes <code>teamleader/_generated/models.py</code> 483 <code>@dataclass</code> base classes \u2705 Yes <code>teamleader/_generated/endpoints.py</code> 290 <code>Endpoint</code> dataclasses + <code>ENDPOINTS</code> dict \u2705 Yes <p>Everything in <code>teamleader/models/</code>, <code>teamleader/resources/</code>, and the rest of the <code>teamleader/</code> package is curated code \u2014 never touched by the generator.</p>"},{"location":"codegen/#update-workflow","title":"Update workflow","text":"<pre><code># 1. Fetch the latest spec from npm and regenerate all three files\npython codegen/generate.py\n\n# 2. Review what changed in the generated layer\ngit diff teamleader/_generated/\n\n# 3. Run the full test suite \u2014 curated code may need updating\npytest\n\n# 4. Fix any curated code broken by schema changes\n#    (new fields, renamed enums, etc.)\n\n# 5. Regenerate the documentation endpoint index\npython codegen/generate_docs_endpoints.py\n\n# 6. Commit both generated files and curated fixes together\ngit add teamleader/_generated/ teamleader/models/ teamleader/resources/ \\\n        codegen/spec/api.yaml docs/api-reference/generated-endpoints.md\ngit commit -m \"chore: update generated layer to spec vX.Y.Z\"\n</code></pre>"},{"location":"codegen/#generator-scripts","title":"Generator scripts","text":"Script Purpose <code>codegen/generate.py</code> Master entry point \u2014 runs all three generators below <code>codegen/fetch_spec.py</code> Downloads the npm tarball, extracts the dereferenced YAML <code>codegen/generate_enums.py</code> Emits <code>teamleader/_generated/enums.py</code> <code>codegen/generate_models.py</code> Emits <code>teamleader/_generated/models.py</code> <code>codegen/generate_endpoints.py</code> Emits <code>teamleader/_generated/endpoints.py</code> <code>codegen/generate_docs_endpoints.py</code> Emits <code>docs/api-reference/generated-endpoints.md</code>"},{"location":"codegen/#key-implementation-details","title":"Key implementation details","text":"Detail Notes Spec tarball path <code>package/dist/api.focus.teamleader.eu.dereferenced.yaml</code> (nested under <code>dist/</code>) All paths are POST Body params live in <code>requestBody.content.application/json.schema.allOf[0]</code> Properties are snake_case No renaming needed \u2014 already conform to Python conventions Hex enum values <code>#00B2B2</code> \u2192 strip underscores before digit-guard \u2192 <code>VALUE_00B2B2</code> <code>oneOf</code> schemas Skipped \u2014 discriminated unions can't be represented as plain dataclasses <code>allOf</code>/<code>oneOf</code> in properties Collapsed to <code>dict[str, Any]</code> \u2014 curated <code>from_api()</code> handles proper deserialisation"},{"location":"codegen/#generated-vs-curated-models","title":"Generated vs. curated models","text":"<p>The generated <code>teamleader/_generated/models.py</code> contains base classes with all fields as <code>Any</code>.  The curated models in <code>teamleader/models/</code> subclass those bases, adding:</p> <ul> <li>Strict type hints</li> <li><code>from_api(dict) -&gt; Self</code> deserialisation</li> <li>Computed <code>@property</code> accessors</li> </ul> <p>When the spec gains new fields on a curated model, add them to the curated class and update <code>from_api()</code> \u2014 do not edit the generated base.</p>"},{"location":"codegen/#re-generating-documentation","title":"Re-generating documentation","text":"<p>The <code>docs/api-reference/generated-endpoints.md</code> page is generated from <code>codegen/spec/api.yaml</code> by <code>codegen/generate_docs_endpoints.py</code>.  It runs automatically as an <code>mkdocs</code> pre-build hook (configured in <code>mkdocs.yml</code>), so a plain <code>mkdocs build</code> or <code>mkdocs serve</code> always reflects the current spec snapshot.</p> <p>Run it manually after a spec update with:</p> <pre><code>python codegen/generate_docs_endpoints.py\n</code></pre>"},{"location":"api-reference/auth/","title":"Auth \u2014 API Reference","text":"<p>OAuth2 Authorization Code flow with automatic refresh-token rotation.</p> <p>See the Django Integration and Non-Django Usage guides for setup examples.</p>"},{"location":"api-reference/auth/#token","title":"Token","text":""},{"location":"api-reference/auth/#teamleader.auth.Token","title":"Token  <code>dataclass</code>","text":"<p>Holds a Teamleader OAuth2 token pair and its expiry time.</p> Source code in <code>teamleader/auth.py</code> <pre><code>@dataclass\nclass Token:\n    \"\"\"Holds a Teamleader OAuth2 token pair and its expiry time.\"\"\"\n\n    access_token: str\n    refresh_token: str\n    expires_at: datetime\n\n    @property\n    def is_expired(self) -&gt; bool:\n        \"\"\"Return True if the token expires within the safety margin.\n\n        The safety margin (``TOKEN_EXPIRY_MARGIN_SECONDS``) means a token is\n        considered expired 60 seconds *before* its actual expiry so that\n        in-flight requests are never rejected mid-call.\n        \"\"\"\n        now = datetime.now(tz=timezone.utc)\n        # Normalise expires_at: if it is naive, assume UTC\n        expires_at = self.expires_at\n        if expires_at.tzinfo is None:\n            expires_at = expires_at.replace(tzinfo=timezone.utc)\n\n        remaining = (expires_at - now).total_seconds()\n        return remaining &lt; TOKEN_EXPIRY_MARGIN_SECONDS\n</code></pre>"},{"location":"api-reference/auth/#teamleader.auth.Token.is_expired","title":"is_expired  <code>property</code>","text":"<pre><code>is_expired: bool\n</code></pre> <p>Return True if the token expires within the safety margin.</p> <p>The safety margin (<code>TOKEN_EXPIRY_MARGIN_SECONDS</code>) means a token is considered expired 60 seconds before its actual expiry so that in-flight requests are never rejected mid-call.</p>"},{"location":"api-reference/auth/#tokenbackend","title":"TokenBackend","text":"<p>Abstract base class for token storage backends.  Implement this to add custom storage (Redis, file, etc.).</p>"},{"location":"api-reference/auth/#teamleader.auth.TokenBackend","title":"TokenBackend","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract storage backend for a single Token instance.</p> Source code in <code>teamleader/auth.py</code> <pre><code>class TokenBackend(ABC):\n    \"\"\"Abstract storage backend for a single Token instance.\"\"\"\n\n    @abstractmethod\n    def get(self) -&gt; Token | None:\n        \"\"\"Return the stored token, or None if none exists.\"\"\"\n\n    @abstractmethod\n    def save(self, token: Token) -&gt; None:\n        \"\"\"Persist *token* to the backend.\"\"\"\n\n    @abstractmethod\n    def clear(self) -&gt; None:\n        \"\"\"Delete any stored token.\"\"\"\n</code></pre>"},{"location":"api-reference/auth/#teamleader.auth.TokenBackend.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get() -&gt; Token | None\n</code></pre> <p>Return the stored token, or None if none exists.</p> Source code in <code>teamleader/auth.py</code> <pre><code>@abstractmethod\ndef get(self) -&gt; Token | None:\n    \"\"\"Return the stored token, or None if none exists.\"\"\"\n</code></pre>"},{"location":"api-reference/auth/#teamleader.auth.TokenBackend.save","title":"save  <code>abstractmethod</code>","text":"<pre><code>save(token: Token) -&gt; None\n</code></pre> <p>Persist token to the backend.</p> Source code in <code>teamleader/auth.py</code> <pre><code>@abstractmethod\ndef save(self, token: Token) -&gt; None:\n    \"\"\"Persist *token* to the backend.\"\"\"\n</code></pre>"},{"location":"api-reference/auth/#teamleader.auth.TokenBackend.clear","title":"clear  <code>abstractmethod</code>","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Delete any stored token.</p> Source code in <code>teamleader/auth.py</code> <pre><code>@abstractmethod\ndef clear(self) -&gt; None:\n    \"\"\"Delete any stored token.\"\"\"\n</code></pre>"},{"location":"api-reference/auth/#memorytokenbackend","title":"MemoryTokenBackend","text":"<p>In-process backend for tests, scripts, and non-Django environments.</p>"},{"location":"api-reference/auth/#teamleader.auth.MemoryTokenBackend","title":"MemoryTokenBackend","text":"<p>               Bases: <code>TokenBackend</code></p> <p>In-process token store \u2014 suitable for tests and non-Django use.</p> Source code in <code>teamleader/auth.py</code> <pre><code>class MemoryTokenBackend(TokenBackend):\n    \"\"\"In-process token store \u2014 suitable for tests and non-Django use.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._token: Token | None = None\n\n    def get(self) -&gt; Token | None:\n        return self._token\n\n    def save(self, token: Token) -&gt; None:\n        self._token = token\n\n    def clear(self) -&gt; None:\n        self._token = None\n</code></pre>"},{"location":"api-reference/auth/#oauth2handler","title":"OAuth2Handler","text":"<p>Full OAuth2 lifecycle: authorization URL \u2192 code exchange \u2192 transparent refresh.</p>"},{"location":"api-reference/auth/#teamleader.auth.OAuth2Handler","title":"OAuth2Handler","text":"<p>Manages the full OAuth2 lifecycle for a Teamleader application.</p> <p>Usage::</p> <pre><code>backend = MemoryTokenBackend()\nhandler = OAuth2Handler(\n    client_id=\"...\",\n    client_secret=\"...\",\n    redirect_uri=\"http://localhost:9999/callback\",\n    token_backend=backend,\n    scopes=[\"contacts\", \"deals\"],\n)\n\n# Step 1 \u2014 send the user to Teamleader\nurl = handler.get_authorization_url()\n\n# Step 2 \u2014 Teamleader redirects back with ?code=...\nhandler.exchange_code(request.GET[\"code\"])\n\n# Step 3 \u2014 use in every API call\naccess_token = handler.get_valid_token()\n</code></pre> Source code in <code>teamleader/auth.py</code> <pre><code>class OAuth2Handler:\n    \"\"\"Manages the full OAuth2 lifecycle for a Teamleader application.\n\n    Usage::\n\n        backend = MemoryTokenBackend()\n        handler = OAuth2Handler(\n            client_id=\"...\",\n            client_secret=\"...\",\n            redirect_uri=\"http://localhost:9999/callback\",\n            token_backend=backend,\n            scopes=[\"contacts\", \"deals\"],\n        )\n\n        # Step 1 \u2014 send the user to Teamleader\n        url = handler.get_authorization_url()\n\n        # Step 2 \u2014 Teamleader redirects back with ?code=...\n        handler.exchange_code(request.GET[\"code\"])\n\n        # Step 3 \u2014 use in every API call\n        access_token = handler.get_valid_token()\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        client_secret: str,\n        redirect_uri: str,\n        token_backend: TokenBackend,\n        scopes: list[str] | None = None,\n    ) -&gt; None:\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.redirect_uri = redirect_uri\n        self.token_backend = token_backend\n        self.scopes = scopes or []\n\n    # ------------------------------------------------------------------\n    # Public interface\n    # ------------------------------------------------------------------\n\n    def get_authorization_url(self) -&gt; str:\n        \"\"\"Build the Teamleader OAuth authorisation URL.\n\n        Returns a fully-qualified URL the user must open in a browser.\n        \"\"\"\n        params: dict[str, str] = {\n            \"client_id\": self.client_id,\n            \"response_type\": \"code\",\n            \"redirect_uri\": self.redirect_uri,\n        }\n        if self.scopes:\n            params[\"scope\"] = \" \".join(self.scopes)\n\n        return f\"{AUTHORIZATION_URL}?{urllib.parse.urlencode(params)}\"\n\n    def exchange_code(self, code: str) -&gt; Token:\n        \"\"\"Exchange an authorisation *code* for tokens and persist them.\n\n        Raises:\n            TeamleaderAuthError: if the token endpoint returns a non-2xx\n                response or the response body is unexpected.\n        \"\"\"\n        payload: dict[str, str] = {\n            \"grant_type\": \"authorization_code\",\n            \"client_id\": self.client_id,\n            \"client_secret\": self.client_secret,\n            \"redirect_uri\": self.redirect_uri,\n            \"code\": code,\n        }\n        token = self._request_token(payload)\n        self.token_backend.save(token)\n        return token\n\n    def get_valid_token(self) -&gt; str:\n        \"\"\"Return a valid access token, refreshing if necessary.\n\n        Raises:\n            TeamleaderAuthError: if no token is stored (authorisation has\n                never been performed).\n            TeamleaderAuthExpiredError: if the refresh token has been\n                revoked and the user must re-authorise.\n        \"\"\"\n        token = self.token_backend.get()\n        if token is None:\n            raise TeamleaderAuthError(\n                \"No token stored. Run `python manage.py teamleader_setup` to \"\n                \"authorise this application with Teamleader.\",\n            )\n\n        if token.is_expired:\n            token = self._refresh(token)\n\n        return token.access_token\n\n    # ------------------------------------------------------------------\n    # Private helpers\n    # ------------------------------------------------------------------\n\n    def _refresh(self, token: Token) -&gt; Token:\n        \"\"\"Use the refresh token to obtain a new access/refresh token pair.\n\n        Persists the new token via the backend on success.\n\n        Raises:\n            TeamleaderAuthExpiredError: if Teamleader rejects the refresh\n                token (revoked or expired).\n        \"\"\"\n        payload: dict[str, str] = {\n            \"grant_type\": \"refresh_token\",\n            \"client_id\": self.client_id,\n            \"client_secret\": self.client_secret,\n            \"refresh_token\": token.refresh_token,\n        }\n        try:\n            new_token = self._request_token(payload)\n        except TeamleaderAuthError as exc:\n            raise TeamleaderAuthExpiredError(\n                \"The Teamleader refresh token has been revoked or has expired. \"\n                \"Re-authorise by running `python manage.py teamleader_setup`.\",\n                status_code=exc.status_code,\n                raw_response=exc.raw_response,\n            ) from exc\n\n        self.token_backend.save(new_token)\n        return new_token\n\n    def _request_token(self, payload: dict[str, Any]) -&gt; Token:\n        \"\"\"POST *payload* to TOKEN_URL and parse the response into a Token.\n\n        Raises:\n            TeamleaderAuthError: on any non-2xx HTTP response.\n        \"\"\"\n        response = requests.post(TOKEN_URL, data=payload, timeout=30)\n\n        if not response.ok:\n            raise TeamleaderAuthError(\n                f\"Token request failed: {response.status_code} {response.text}\",\n                status_code=response.status_code,\n                raw_response=response,\n            )\n\n        data: dict[str, Any] = response.json()\n\n        try:\n            access_token: str = data[\"access_token\"]\n            refresh_token: str = data[\"refresh_token\"]\n            expires_in: int = int(data[\"expires_in\"])\n        except (KeyError, TypeError, ValueError) as exc:\n            raise TeamleaderAuthError(\n                f\"Unexpected token response format: {data!r}\",\n                raw_response=response,\n            ) from exc\n\n        expires_at = (\n            datetime.now(tz=timezone.utc).replace(microsecond=0)\n            + timedelta(seconds=expires_in)\n        )\n\n        return Token(\n            access_token=access_token,\n            refresh_token=refresh_token,\n            expires_at=expires_at,\n        )\n</code></pre>"},{"location":"api-reference/auth/#teamleader.auth.OAuth2Handler.get_authorization_url","title":"get_authorization_url","text":"<pre><code>get_authorization_url() -&gt; str\n</code></pre> <p>Build the Teamleader OAuth authorisation URL.</p> <p>Returns a fully-qualified URL the user must open in a browser.</p> Source code in <code>teamleader/auth.py</code> <pre><code>def get_authorization_url(self) -&gt; str:\n    \"\"\"Build the Teamleader OAuth authorisation URL.\n\n    Returns a fully-qualified URL the user must open in a browser.\n    \"\"\"\n    params: dict[str, str] = {\n        \"client_id\": self.client_id,\n        \"response_type\": \"code\",\n        \"redirect_uri\": self.redirect_uri,\n    }\n    if self.scopes:\n        params[\"scope\"] = \" \".join(self.scopes)\n\n    return f\"{AUTHORIZATION_URL}?{urllib.parse.urlencode(params)}\"\n</code></pre>"},{"location":"api-reference/auth/#teamleader.auth.OAuth2Handler.exchange_code","title":"exchange_code","text":"<pre><code>exchange_code(code: str) -&gt; Token\n</code></pre> <p>Exchange an authorisation code for tokens and persist them.</p> <p>Raises:     TeamleaderAuthError: if the token endpoint returns a non-2xx         response or the response body is unexpected.</p> Source code in <code>teamleader/auth.py</code> <pre><code>def exchange_code(self, code: str) -&gt; Token:\n    \"\"\"Exchange an authorisation *code* for tokens and persist them.\n\n    Raises:\n        TeamleaderAuthError: if the token endpoint returns a non-2xx\n            response or the response body is unexpected.\n    \"\"\"\n    payload: dict[str, str] = {\n        \"grant_type\": \"authorization_code\",\n        \"client_id\": self.client_id,\n        \"client_secret\": self.client_secret,\n        \"redirect_uri\": self.redirect_uri,\n        \"code\": code,\n    }\n    token = self._request_token(payload)\n    self.token_backend.save(token)\n    return token\n</code></pre>"},{"location":"api-reference/auth/#teamleader.auth.OAuth2Handler.get_valid_token","title":"get_valid_token","text":"<pre><code>get_valid_token() -&gt; str\n</code></pre> <p>Return a valid access token, refreshing if necessary.</p> <p>Raises:     TeamleaderAuthError: if no token is stored (authorisation has         never been performed).     TeamleaderAuthExpiredError: if the refresh token has been         revoked and the user must re-authorise.</p> Source code in <code>teamleader/auth.py</code> <pre><code>def get_valid_token(self) -&gt; str:\n    \"\"\"Return a valid access token, refreshing if necessary.\n\n    Raises:\n        TeamleaderAuthError: if no token is stored (authorisation has\n            never been performed).\n        TeamleaderAuthExpiredError: if the refresh token has been\n            revoked and the user must re-authorise.\n    \"\"\"\n    token = self.token_backend.get()\n    if token is None:\n        raise TeamleaderAuthError(\n            \"No token stored. Run `python manage.py teamleader_setup` to \"\n            \"authorise this application with Teamleader.\",\n        )\n\n    if token.is_expired:\n        token = self._refresh(token)\n\n    return token.access_token\n</code></pre>"},{"location":"api-reference/auth/#databasetokenbackend-django-only","title":"DatabaseTokenBackend (Django only)","text":"<p>Stores the token pair in a Django database table (<code>TeamleaderToken</code> singleton). Requires <code>pip install teamleader-sdk[django]</code>.</p>"},{"location":"api-reference/auth/#teamleader.django.token_store.DatabaseTokenBackend","title":"DatabaseTokenBackend","text":"<p>               Bases: <code>TokenBackend</code></p> <p>Stores the OAuth2 token in the <code>TeamleaderToken</code> Django model.</p> <p>Uses <code>select_for_update()</code> inside <code>transaction.atomic()</code> to prevent race conditions in multi-worker deployments.</p> Source code in <code>teamleader/django/token_store.py</code> <pre><code>class DatabaseTokenBackend(TokenBackend):\n    \"\"\"Stores the OAuth2 token in the ``TeamleaderToken`` Django model.\n\n    Uses ``select_for_update()`` inside ``transaction.atomic()`` to\n    prevent race conditions in multi-worker deployments.\n    \"\"\"\n\n    def get(self) -&gt; Token | None:\n        \"\"\"Return the stored token, or ``None`` if no row exists yet.\"\"\"\n        # Import here to avoid Django app-registry issues at module load time.\n        from teamleader.django.models import TeamleaderToken\n\n        try:\n            obj = TeamleaderToken.objects.get(pk=1)\n        except TeamleaderToken.DoesNotExist:\n            return None\n\n        return Token(\n            access_token=obj.access_token,\n            refresh_token=obj.refresh_token,\n            expires_at=obj.expires_at,\n        )\n\n    def save(self, token: Token) -&gt; None:\n        \"\"\"Upsert the singleton row inside a serialisable transaction.\"\"\"\n        from django.db import transaction\n\n        from teamleader.django.models import TeamleaderToken\n\n        with transaction.atomic():\n            # Lock the row (or the gap) so concurrent workers don't race.\n            obj = TeamleaderToken.objects.select_for_update().filter(pk=1).first()\n            if obj is None:\n                obj = TeamleaderToken(pk=1)\n            obj.access_token = token.access_token\n            obj.refresh_token = token.refresh_token\n            obj.expires_at = token.expires_at\n            obj.save()\n\n    def clear(self) -&gt; None:\n        \"\"\"Delete the singleton row (no-op if it does not exist).\"\"\"\n        from teamleader.django.models import TeamleaderToken\n\n        TeamleaderToken.objects.filter(pk=1).delete()\n</code></pre>"},{"location":"api-reference/auth/#teamleader.django.token_store.DatabaseTokenBackend.get","title":"get","text":"<pre><code>get() -&gt; Token | None\n</code></pre> <p>Return the stored token, or <code>None</code> if no row exists yet.</p> Source code in <code>teamleader/django/token_store.py</code> <pre><code>def get(self) -&gt; Token | None:\n    \"\"\"Return the stored token, or ``None`` if no row exists yet.\"\"\"\n    # Import here to avoid Django app-registry issues at module load time.\n    from teamleader.django.models import TeamleaderToken\n\n    try:\n        obj = TeamleaderToken.objects.get(pk=1)\n    except TeamleaderToken.DoesNotExist:\n        return None\n\n    return Token(\n        access_token=obj.access_token,\n        refresh_token=obj.refresh_token,\n        expires_at=obj.expires_at,\n    )\n</code></pre>"},{"location":"api-reference/auth/#teamleader.django.token_store.DatabaseTokenBackend.save","title":"save","text":"<pre><code>save(token: Token) -&gt; None\n</code></pre> <p>Upsert the singleton row inside a serialisable transaction.</p> Source code in <code>teamleader/django/token_store.py</code> <pre><code>def save(self, token: Token) -&gt; None:\n    \"\"\"Upsert the singleton row inside a serialisable transaction.\"\"\"\n    from django.db import transaction\n\n    from teamleader.django.models import TeamleaderToken\n\n    with transaction.atomic():\n        # Lock the row (or the gap) so concurrent workers don't race.\n        obj = TeamleaderToken.objects.select_for_update().filter(pk=1).first()\n        if obj is None:\n            obj = TeamleaderToken(pk=1)\n        obj.access_token = token.access_token\n        obj.refresh_token = token.refresh_token\n        obj.expires_at = token.expires_at\n        obj.save()\n</code></pre>"},{"location":"api-reference/auth/#teamleader.django.token_store.DatabaseTokenBackend.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Delete the singleton row (no-op if it does not exist).</p> Source code in <code>teamleader/django/token_store.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Delete the singleton row (no-op if it does not exist).\"\"\"\n    from teamleader.django.models import TeamleaderToken\n\n    TeamleaderToken.objects.filter(pk=1).delete()\n</code></pre>"},{"location":"api-reference/client/","title":"TeamleaderClient \u2014 API Reference","text":"<p><code>TeamleaderClient</code> is the entry point for all API calls.  It handles Bearer token injection, response parsing, and exposes the five curated resource attributes.</p> <p>See Non-Django Usage and Django Integration for construction examples.</p>"},{"location":"api-reference/client/#two-ways-to-call-the-api","title":"Two ways to call the API","text":"Approach How Returns When to use Curated resources <code>client.contacts.get(id)</code> Typed model (<code>Contact</code>, <code>Deal</code>, \u2026) The 5 supported resource families <code>call()</code> bridge <code>client.call(\"tickets.list\", \u2026)</code> Raw <code>dict</code> Any of the 290 generated endpoints <p>The <code>call()</code> method accepts any operation ID from the Generated Endpoint Reference and validates required parameters before sending the request.</p>"},{"location":"api-reference/client/#teamleader.client.TeamleaderClient","title":"TeamleaderClient","text":"<p>Entry point for all Teamleader API interactions.</p> <p>Parameters:</p> Name Type Description Default <code>auth_handler</code> <code>OAuth2Handler</code> <p>Fully configured :class:<code>~teamleader.auth.OAuth2Handler</code>.  The handler is responsible for obtaining and refreshing access tokens; the client calls :meth:<code>~teamleader.auth.OAuth2Handler.get_valid_token</code> before every request so tokens are transparently refreshed as needed.</p> required <code>timeout</code> <code>int</code> <p>HTTP request timeout in seconds.  Defaults to :data:<code>~teamleader.constants.DEFAULT_TIMEOUT</code> (30 s).</p> <code>DEFAULT_TIMEOUT</code> Source code in <code>teamleader/client.py</code> <pre><code>class TeamleaderClient:\n    \"\"\"Entry point for all Teamleader API interactions.\n\n    Parameters\n    ----------\n    auth_handler:\n        Fully configured :class:`~teamleader.auth.OAuth2Handler`.  The handler\n        is responsible for obtaining and refreshing access tokens; the client\n        calls :meth:`~teamleader.auth.OAuth2Handler.get_valid_token` before\n        every request so tokens are transparently refreshed as needed.\n    timeout:\n        HTTP request timeout in seconds.  Defaults to\n        :data:`~teamleader.constants.DEFAULT_TIMEOUT` (30 s).\n    \"\"\"\n\n    def __init__(\n        self,\n        auth_handler: OAuth2Handler,\n        *,\n        timeout: int = DEFAULT_TIMEOUT,\n    ) -&gt; None:\n        self._auth = auth_handler\n        self._timeout = timeout\n        self._session = requests.Session()\n\n        # Typed resource attributes \u2014 available immediately after construction.\n        # Concrete methods raise NotImplementedError until Phase 7/9.\n        self.contacts: ContactsResource = ContactsResource(self)\n        self.companies: CompaniesResource = CompaniesResource(self)\n        self.deals: DealsResource = DealsResource(self)\n        self.invoices: InvoicesResource = InvoicesResource(self)\n        self.quotations: QuotationsResource = QuotationsResource(self)\n\n    # ------------------------------------------------------------------\n    # Public generic caller\n    # ------------------------------------------------------------------\n\n    def call(self, operation_id: str, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Call any Teamleader API endpoint by its operation ID.\n\n        Uses the generated :data:`~teamleader._generated.endpoints.ENDPOINTS`\n        registry to look up the request path and validate required parameters\n        **before** the HTTP request is sent.\n\n        Parameters\n        ----------\n        operation_id:\n            The Teamleader API operation ID exactly as it appears in\n            :data:`~teamleader._generated.endpoints.ENDPOINTS`, e.g.\n            ``\"tickets.list\"``, ``\"activityTypes.list\"``, ``\"users.me\"``.\n        **kwargs:\n            Request body parameters forwarded directly to the API as JSON.\n            Required parameters for the chosen endpoint are validated; a\n            ``ValueError`` is raised if any are missing.\n\n        Returns\n        -------\n        dict[str, Any]:\n            Raw response dictionary from the API.  Unlike curated resource\n            methods (e.g. :meth:`~teamleader.resources.contacts.ContactsResource.get`),\n            this does **not** deserialise into a typed model \u2014 the caller\n            receives the JSON body as-is.\n\n        Raises\n        ------\n        ValueError\n            If *operation_id* is not in ``ENDPOINTS``, or if one or more\n            required parameters are absent from *kwargs*.\n        TeamleaderError\n            Any HTTP-level error raised by the underlying transport layer\n            (same exceptions as the curated resources).\n\n        Examples\n        --------\n        List activity types (no required params):\n\n        .. code-block:: python\n\n            result = client.call(\"activityTypes.list\", page={\"size\": 20, \"number\": 1})\n            for item in result[\"data\"]:\n                print(item[\"name\"])\n\n        Fetch a single department (``id`` is required):\n\n        .. code-block:: python\n\n            dept = client.call(\"departments.info\", id=\"67c576e7-7e6f-465d-b6ab-a864f6e5e95b\")\n            print(dept[\"data\"][\"name\"])\n        \"\"\"\n        endpoint = ENDPOINTS.get(operation_id)\n        if endpoint is None:\n            raise ValueError(\n                f\"Unknown operation_id {operation_id!r}. \"\n                f\"See teamleader._generated.endpoints.ENDPOINTS.keys() for the \"\n                f\"full list of {len(ENDPOINTS)} available operation IDs.\"\n            )\n\n        missing = [p for p in endpoint.required_params if p not in kwargs]\n        if missing:\n            raise ValueError(\n                f\"Missing required parameter(s) for {operation_id!r}: \"\n                f\"{missing}. \"\n                f\"Required: {list(endpoint.required_params)}, \"\n                f\"optional: {list(endpoint.optional_params)}.\"\n            )\n\n        # endpoint.path is \"/contacts.list\"; _post expects \"contacts.list\"\n        return self._post(endpoint.path.lstrip(\"/\"), kwargs if kwargs else None)\n\n    # ------------------------------------------------------------------\n    # Private helpers\n    # ------------------------------------------------------------------\n\n    def _auth_headers(self) -&gt; dict[str, str]:\n        \"\"\"Return an ``Authorization`` header with a fresh Bearer token.\n\n        Calls :meth:`~teamleader.auth.OAuth2Handler.get_valid_token`, which\n        transparently refreshes the token if it is within the expiry margin.\n        \"\"\"\n        token = self._auth.get_valid_token()\n        return {\"Authorization\": f\"Bearer {token}\"}\n\n    # ------------------------------------------------------------------\n    # Internal HTTP helpers\n    # ------------------------------------------------------------------\n\n    def _get(\n        self,\n        path: str,\n        params: dict[str, Any] | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Make an authenticated GET request and return the parsed JSON body.\n\n        Parameters\n        ----------\n        path:\n            API path segment, e.g. ``\"users.me\"``.  Appended to\n            :data:`~teamleader.constants.BASE_URL` with a ``/`` separator.\n        params:\n            Optional query-string parameters.\n        \"\"\"\n        response = self._session.get(\n            f\"{BASE_URL}/{path}\",\n            headers=self._auth_headers(),\n            params=params,\n            timeout=self._timeout,\n        )\n        return self._handle_response(response)\n\n    def _post(\n        self,\n        path: str,\n        json: dict[str, Any] | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Make an authenticated POST request and return the parsed JSON body.\n\n        Parameters\n        ----------\n        path:\n            API path segment, e.g. ``\"contacts.list\"``.  Appended to\n            :data:`~teamleader.constants.BASE_URL` with a ``/`` separator.\n        json:\n            Request body serialised as JSON.  Pass ``None`` for endpoints\n            that take no body.\n        \"\"\"\n        response = self._session.post(\n            f\"{BASE_URL}/{path}\",\n            headers=self._auth_headers(),\n            json=json,\n            timeout=self._timeout,\n        )\n        return self._handle_response(response)\n\n    def _handle_response(self, response: requests.Response) -&gt; dict[str, Any]:\n        \"\"\"Map HTTP status codes to SDK exceptions; return the body on success.\n\n        Success path (2xx):\n            Returns the parsed JSON dict, or an empty dict for empty bodies\n            (e.g. 204 No Content).\n\n        Error path:\n            Raises the most specific :exc:`~teamleader.exceptions.TeamleaderError`\n            subclass that matches the status code.\n\n        Status mapping\n        --------------\n        - 401 \u2192 :exc:`~teamleader.exceptions.TeamleaderAuthError`\n        - 403 \u2192 :exc:`~teamleader.exceptions.TeamleaderPermissionError`\n        - 404 \u2192 :exc:`~teamleader.exceptions.TeamleaderNotFoundError`\n        - 422 \u2192 :exc:`~teamleader.exceptions.TeamleaderValidationError`\n        - 429 \u2192 :exc:`~teamleader.exceptions.TeamleaderRateLimitError`\n          (``retry_after`` populated from the ``Retry-After`` response header)\n        - 5xx \u2192 :exc:`~teamleader.exceptions.TeamleaderServerError`\n        - other 4xx \u2192 :exc:`~teamleader.exceptions.TeamleaderAPIError`\n        \"\"\"\n        status = response.status_code\n\n        # ---- success -------------------------------------------------\n        if status &lt; 300:\n            if not response.content:\n                return {}\n            return response.json()  # type: ignore[no-any-return]\n\n        # ---- error \u2014 shared keyword args ----------------------------\n        message = self._extract_message(response)\n        err_kwargs: dict[str, Any] = {\n            \"status_code\": status,\n            \"raw_response\": response,\n        }\n\n        if status == 401:\n            raise TeamleaderAuthError(message, **err_kwargs)\n        if status == 403:\n            raise TeamleaderPermissionError(message, **err_kwargs)\n        if status == 404:\n            raise TeamleaderNotFoundError(message, **err_kwargs)\n        if status == 422:\n            raise TeamleaderValidationError(message, **err_kwargs)\n        if status == 429:\n            retry_after_raw = response.headers.get(\"Retry-After\")\n            retry_after = int(retry_after_raw) if retry_after_raw is not None else None\n            raise TeamleaderRateLimitError(\n                message,\n                retry_after=retry_after,\n                **err_kwargs,\n            )\n        if status &gt;= 500:\n            raise TeamleaderServerError(message, **err_kwargs)\n\n        # Unexpected 4xx (e.g. 400, 409)\n        raise TeamleaderAPIError(message, **err_kwargs)\n\n    @staticmethod\n    def _extract_message(response: requests.Response) -&gt; str:\n        \"\"\"Best-effort extraction of an error message from the response body.\n\n        Understands two common Teamleader error shapes:\n\n        JSON:API (most endpoints)::\n\n            {\"errors\": [{\"title\": \"The contact was not found.\"}, ...]}\n\n        OAuth-style (token endpoint)::\n\n            {\"error\": \"invalid_grant\", \"error_description\": \"Token expired.\"}\n\n        Falls back to the raw response text, or ``\"HTTP &lt;status&gt;\"`` if the\n        body is empty.\n        \"\"\"\n        try:\n            body: dict[str, Any] = response.json()\n        except ValueError:\n            return response.text or f\"HTTP {response.status_code}\"\n\n        # JSON:API error array\n        errors = body.get(\"errors\")\n        if isinstance(errors, list) and errors:\n            titles = [\n                e.get(\"title\", \"\")\n                for e in errors\n                if isinstance(e, dict)\n            ]\n            joined = \"; \".join(t for t in titles if t)\n            return joined or response.text or f\"HTTP {response.status_code}\"\n\n        # OAuth / generic single-message shapes\n        for key in (\"error_description\", \"message\", \"error\"):\n            value = body.get(key)\n            if isinstance(value, str) and value:\n                return value\n\n        return response.text or f\"HTTP {response.status_code}\"\n</code></pre>"},{"location":"api-reference/client/#teamleader.client.TeamleaderClient.call","title":"call","text":"<pre><code>call(operation_id: str, **kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Call any Teamleader API endpoint by its operation ID.</p> <p>Uses the generated :data:<code>~teamleader._generated.endpoints.ENDPOINTS</code> registry to look up the request path and validate required parameters before the HTTP request is sent.</p> <p>Parameters:</p> Name Type Description Default <code>operation_id</code> <code>str</code> <p>The Teamleader API operation ID exactly as it appears in :data:<code>~teamleader._generated.endpoints.ENDPOINTS</code>, e.g. <code>\"tickets.list\"</code>, <code>\"activityTypes.list\"</code>, <code>\"users.me\"</code>.</p> required <code>**kwargs</code> <code>Any</code> <p>Request body parameters forwarded directly to the API as JSON. Required parameters for the chosen endpoint are validated; a <code>ValueError</code> is raised if any are missing.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]:</code> <p>Raw response dictionary from the API.  Unlike curated resource methods (e.g. :meth:<code>~teamleader.resources.contacts.ContactsResource.get</code>), this does not deserialise into a typed model \u2014 the caller receives the JSON body as-is.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operation_id is not in <code>ENDPOINTS</code>, or if one or more required parameters are absent from kwargs.</p> <code>TeamleaderError</code> <p>Any HTTP-level error raised by the underlying transport layer (same exceptions as the curated resources).</p> <p>Examples:</p> <p>List activity types (no required params):</p> <p>.. code-block:: python</p> <pre><code>result = client.call(\"activityTypes.list\", page={\"size\": 20, \"number\": 1})\nfor item in result[\"data\"]:\n    print(item[\"name\"])\n</code></pre> <p>Fetch a single department (<code>id</code> is required):</p> <p>.. code-block:: python</p> <pre><code>dept = client.call(\"departments.info\", id=\"67c576e7-7e6f-465d-b6ab-a864f6e5e95b\")\nprint(dept[\"data\"][\"name\"])\n</code></pre> Source code in <code>teamleader/client.py</code> <pre><code>def call(self, operation_id: str, **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Call any Teamleader API endpoint by its operation ID.\n\n    Uses the generated :data:`~teamleader._generated.endpoints.ENDPOINTS`\n    registry to look up the request path and validate required parameters\n    **before** the HTTP request is sent.\n\n    Parameters\n    ----------\n    operation_id:\n        The Teamleader API operation ID exactly as it appears in\n        :data:`~teamleader._generated.endpoints.ENDPOINTS`, e.g.\n        ``\"tickets.list\"``, ``\"activityTypes.list\"``, ``\"users.me\"``.\n    **kwargs:\n        Request body parameters forwarded directly to the API as JSON.\n        Required parameters for the chosen endpoint are validated; a\n        ``ValueError`` is raised if any are missing.\n\n    Returns\n    -------\n    dict[str, Any]:\n        Raw response dictionary from the API.  Unlike curated resource\n        methods (e.g. :meth:`~teamleader.resources.contacts.ContactsResource.get`),\n        this does **not** deserialise into a typed model \u2014 the caller\n        receives the JSON body as-is.\n\n    Raises\n    ------\n    ValueError\n        If *operation_id* is not in ``ENDPOINTS``, or if one or more\n        required parameters are absent from *kwargs*.\n    TeamleaderError\n        Any HTTP-level error raised by the underlying transport layer\n        (same exceptions as the curated resources).\n\n    Examples\n    --------\n    List activity types (no required params):\n\n    .. code-block:: python\n\n        result = client.call(\"activityTypes.list\", page={\"size\": 20, \"number\": 1})\n        for item in result[\"data\"]:\n            print(item[\"name\"])\n\n    Fetch a single department (``id`` is required):\n\n    .. code-block:: python\n\n        dept = client.call(\"departments.info\", id=\"67c576e7-7e6f-465d-b6ab-a864f6e5e95b\")\n        print(dept[\"data\"][\"name\"])\n    \"\"\"\n    endpoint = ENDPOINTS.get(operation_id)\n    if endpoint is None:\n        raise ValueError(\n            f\"Unknown operation_id {operation_id!r}. \"\n            f\"See teamleader._generated.endpoints.ENDPOINTS.keys() for the \"\n            f\"full list of {len(ENDPOINTS)} available operation IDs.\"\n        )\n\n    missing = [p for p in endpoint.required_params if p not in kwargs]\n    if missing:\n        raise ValueError(\n            f\"Missing required parameter(s) for {operation_id!r}: \"\n            f\"{missing}. \"\n            f\"Required: {list(endpoint.required_params)}, \"\n            f\"optional: {list(endpoint.optional_params)}.\"\n        )\n\n    # endpoint.path is \"/contacts.list\"; _post expects \"contacts.list\"\n    return self._post(endpoint.path.lstrip(\"/\"), kwargs if kwargs else None)\n</code></pre>"},{"location":"api-reference/client/#resource-attributes","title":"Resource attributes","text":"Attribute Type Description <code>contacts</code> <code>ContactsResource</code> CRUD + tag/untag/link operations on contacts <code>companies</code> <code>CompaniesResource</code> CRUD + tag/untag operations on companies <code>deals</code> <code>DealsResource</code> CRUD + phase/win/lose/list_phases/list_sources <code>invoices</code> <code>InvoicesResource</code> CRUD + book/credit/register_payment/send/download <code>quotations</code> <code>QuotationsResource</code> CRUD + send/accept"},{"location":"api-reference/client/#http-internals","title":"HTTP internals","text":"<p>All Teamleader API calls are <code>POST</code> requests (per the Teamleader API convention). <code>TeamleaderClient</code> exposes two internal helpers used by resources:</p> <ul> <li><code>_post(path, json)</code> \u2014 POST body, deserialise response</li> <li><code>_get(path, params)</code> \u2014 GET with query params (used for a small number of endpoints)</li> </ul> <p>Both methods call <code>_auth_headers()</code> which transparently refreshes the access token via <code>OAuth2Handler.get_valid_token()</code> if it is expired.</p>"},{"location":"api-reference/exceptions/","title":"Exceptions \u2014 API Reference","text":"<p>All SDK exceptions inherit from <code>TeamleaderError</code>. See the Error Handling guide for usage patterns and a visual hierarchy diagram.</p>"},{"location":"api-reference/exceptions/#base","title":"Base","text":""},{"location":"api-reference/exceptions/#teamleader.exceptions.TeamleaderError","title":"TeamleaderError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for every exception raised by this SDK.</p> Source code in <code>teamleader/exceptions.py</code> <pre><code>class TeamleaderError(Exception):\n    \"\"\"Base class for every exception raised by this SDK.\"\"\"\n\n    def __init__(\n        self,\n        message: str = \"\",\n        *,\n        status_code: int | None = None,\n        raw_response: Any = None,\n    ) -&gt; None:\n        super().__init__(message)\n        self.message = message\n        self.status_code = status_code\n        self.raw_response = raw_response\n\n    def __repr__(self) -&gt; str:  # pragma: no cover\n        return (\n            f\"{self.__class__.__name__}(\"\n            f\"message={self.message!r}, \"\n            f\"status_code={self.status_code!r})\"\n        )\n</code></pre>"},{"location":"api-reference/exceptions/#api-http-errors","title":"API / HTTP errors","text":""},{"location":"api-reference/exceptions/#teamleader.exceptions.TeamleaderAPIError","title":"TeamleaderAPIError","text":"<p>               Bases: <code>TeamleaderError</code></p> <p>Raised when the Teamleader API returns an unexpected HTTP status.</p> Source code in <code>teamleader/exceptions.py</code> <pre><code>class TeamleaderAPIError(TeamleaderError):\n    \"\"\"Raised when the Teamleader API returns an unexpected HTTP status.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#teamleader.exceptions.TeamleaderNotFoundError","title":"TeamleaderNotFoundError","text":"<p>               Bases: <code>TeamleaderAPIError</code></p> <p>404 \u2014 the requested resource does not exist.</p> Source code in <code>teamleader/exceptions.py</code> <pre><code>class TeamleaderNotFoundError(TeamleaderAPIError):\n    \"\"\"404 \u2014 the requested resource does not exist.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#teamleader.exceptions.TeamleaderRateLimitError","title":"TeamleaderRateLimitError","text":"<p>               Bases: <code>TeamleaderAPIError</code></p> <p>429 \u2014 rate limit exceeded; inspect <code>retry_after</code> for back-off.</p> Source code in <code>teamleader/exceptions.py</code> <pre><code>class TeamleaderRateLimitError(TeamleaderAPIError):\n    \"\"\"429 \u2014 rate limit exceeded; inspect ``retry_after`` for back-off.\"\"\"\n\n    def __init__(\n        self,\n        message: str = \"\",\n        *,\n        status_code: int | None = 429,\n        raw_response: Any = None,\n        retry_after: int | None = None,\n    ) -&gt; None:\n        super().__init__(message, status_code=status_code, raw_response=raw_response)\n        self.retry_after = retry_after\n</code></pre>"},{"location":"api-reference/exceptions/#teamleader.exceptions.TeamleaderServerError","title":"TeamleaderServerError","text":"<p>               Bases: <code>TeamleaderAPIError</code></p> <p>5xx \u2014 the Teamleader server returned an internal error.</p> Source code in <code>teamleader/exceptions.py</code> <pre><code>class TeamleaderServerError(TeamleaderAPIError):\n    \"\"\"5xx \u2014 the Teamleader server returned an internal error.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#auth-errors","title":"Auth errors","text":""},{"location":"api-reference/exceptions/#teamleader.exceptions.TeamleaderAuthError","title":"TeamleaderAuthError","text":"<p>               Bases: <code>TeamleaderError</code></p> <p>401 \u2014 request was not authenticated or the token is invalid.</p> Source code in <code>teamleader/exceptions.py</code> <pre><code>class TeamleaderAuthError(TeamleaderError):\n    \"\"\"401 \u2014 request was not authenticated or the token is invalid.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#teamleader.exceptions.TeamleaderAuthExpiredError","title":"TeamleaderAuthExpiredError","text":"<p>               Bases: <code>TeamleaderAuthError</code></p> <p>The refresh token has been revoked or has expired.</p> <p>The user must re-authorise via <code>python manage.py teamleader_setup</code>.</p> Source code in <code>teamleader/exceptions.py</code> <pre><code>class TeamleaderAuthExpiredError(TeamleaderAuthError):\n    \"\"\"The refresh token has been revoked or has expired.\n\n    The user must re-authorise via ``python manage.py teamleader_setup``.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#request-errors","title":"Request errors","text":""},{"location":"api-reference/exceptions/#teamleader.exceptions.TeamleaderValidationError","title":"TeamleaderValidationError","text":"<p>               Bases: <code>TeamleaderError</code></p> <p>422 \u2014 the request body failed server-side validation.</p> Source code in <code>teamleader/exceptions.py</code> <pre><code>class TeamleaderValidationError(TeamleaderError):\n    \"\"\"422 \u2014 the request body failed server-side validation.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#teamleader.exceptions.TeamleaderPermissionError","title":"TeamleaderPermissionError","text":"<p>               Bases: <code>TeamleaderError</code></p> <p>403 \u2014 the OAuth token lacks the required scope for this operation.</p> Source code in <code>teamleader/exceptions.py</code> <pre><code>class TeamleaderPermissionError(TeamleaderError):\n    \"\"\"403 \u2014 the OAuth token lacks the required scope for this operation.\"\"\"\n</code></pre>"},{"location":"api-reference/generated-endpoints/","title":"Generated API Endpoint Reference","text":"<p>Note</p> <p>Auto-generated from <code>codegen/spec/api.yaml</code> (spec v1.112.0). Run <code>python codegen/generate_docs_endpoints.py</code> to refresh after a spec update.</p> <p>Every Teamleader Focus API endpoint is a POST request.  The table below groups endpoints by the resource tag used in the official Teamleader documentation.</p>"},{"location":"api-reference/generated-endpoints/#calling-endpoints-via-clientcall","title":"Calling endpoints via <code>client.call()</code>","text":"<p>Every endpoint listed here can be called through <code>TeamleaderClient.call()</code> using the operation ID shown in the table (the <code>\u2022 client.call()</code> column):</p> <pre><code># Example \u2014 list activity types (no required params)\nresult = client.call(\"activityTypes.list\", page={\"size\": 20, \"number\": 1})\nfor item in result[\"data\"]:\n    print(item[\"name\"])\n\n# Example \u2014 fetch a department by ID (id is required)\ndept = client.call(\"departments.info\", id=\"67c576e7-7e6f-465d-b6ab-a864f6e5e95b\")\nprint(dept[\"data\"][\"name\"])\n</code></pre> <p>Tip</p> <p><code>call()</code> validates required parameters before making the HTTP request and raises <code>ValueError</code> with a helpful message if any are missing. The response is a raw <code>dict</code> \u2014 no model deserialisation.</p>"},{"location":"api-reference/generated-endpoints/#departments","title":"Departments","text":"<p>Departments are used to split quotations and invoices for different legal entities or within one organisation.</p> Endpoint Summary Description <code>client.call()</code> <code>/departments.info</code> <code>departments.info</code> Get details for a single department <code>client.call('departments.info')</code> <code>/departments.list</code> <code>departments.list</code> Get a list of departments <code>client.call('departments.list')</code>"},{"location":"api-reference/generated-endpoints/#users","title":"Users","text":"<p>Users are co-workers in a Teamleader account.</p> Endpoint Summary Description <code>client.call()</code> <code>/users.getWeekSchedule</code> <code>users.getWeekSchedule</code> Returns information about week schedule of a user. Only available with the Weekly working schedule feature <code>client.call('users.getWeekSchedule')</code> <code>/users.info</code> <code>users.info</code> Get details for a single user <code>client.call('users.info')</code> <code>/users.list</code> <code>users.list</code> Get a list of all users <code>client.call('users.list')</code> <code>/users.listDaysOff</code> <code>users.listDaysOff</code> Returns information about days off of a given user <code>client.call('users.listDaysOff')</code> <code>/users.me</code> <code>users.me</code> Get the current authenticated user <code>client.call('users.me')</code>"},{"location":"api-reference/generated-endpoints/#teams","title":"Teams","text":"Endpoint Summary Description <code>client.call()</code> <code>/teams.list</code> <code>teams.list</code> Gets a list of all teams <code>client.call('teams.list')</code>"},{"location":"api-reference/generated-endpoints/#custom-fields","title":"Custom Fields","text":"<p>Custom fields are used to add additional data/properties to entities within Teamleader.</p> Endpoint Summary Description <code>client.call()</code> <code>/customFieldDefinitions.create</code> <code>customFieldDefinitions.create</code> Create a custom field definition <code>client.call('customFieldDefinitions.create')</code> <code>/customFieldDefinitions.info</code> <code>customFieldDefinitions.info</code> Get info about a specific custom field definition <code>client.call('customFieldDefinitions.info')</code> <code>/customFieldDefinitions.list</code> <code>customFieldDefinitions.list</code> Get a list of all the definitions of custom fields <code>client.call('customFieldDefinitions.list')</code>"},{"location":"api-reference/generated-endpoints/#work-types","title":"Work Types","text":"<p>Work types define the type of work for events or time tracking. Hourly rates can be added to work types, so that the work can be billed to a customer.</p> Endpoint Summary Description <code>client.call()</code> <code>/workTypes.list</code> <code>workTypes.list</code> Get a list of all work types, sorted alphabetically (on their name) <code>client.call('workTypes.list')</code>"},{"location":"api-reference/generated-endpoints/#document-templates","title":"Document Templates","text":"<p>Document Templates</p> Endpoint Summary Description <code>client.call()</code> <code>/documentTemplates.list</code> <code>documentTemplates.list</code> Get a list of all document templates <code>client.call('documentTemplates.list')</code>"},{"location":"api-reference/generated-endpoints/#currencies","title":"Currencies","text":"<p>Currencies</p> Endpoint Summary Description <code>client.call()</code> <code>/currencies.exchangeRates</code> <code>currencies.exchangeRates</code> Get a list of exchange rates for a provided currency <code>client.call('currencies.exchangeRates')</code>"},{"location":"api-reference/generated-endpoints/#notes","title":"Notes","text":"<p>Notes</p> Endpoint Summary Description <code>client.call()</code> <code>/notes.create</code> <code>notes.create</code> Create a new note <code>client.call('notes.create')</code> <code>/notes.list</code> <code>notes.list</code> Get a list of all notes <code>client.call('notes.list')</code> <code>/notes.update</code> <code>notes.update</code> Update an existing note <code>client.call('notes.update')</code>"},{"location":"api-reference/generated-endpoints/#email-tracking","title":"Email Tracking","text":"<p>Email Tracking</p> Endpoint Summary Description <code>client.call()</code> <code>/emailTracking.create</code> <code>emailTracking.create</code> Create a new email tracking <code>client.call('emailTracking.create')</code> <code>/emailTracking.list</code> <code>emailTracking.list</code> Get a list of all email tracking <code>client.call('emailTracking.list')</code>"},{"location":"api-reference/generated-endpoints/#closing-days","title":"Closing Days","text":"<p>Closing Days</p> Endpoint Summary Description <code>client.call()</code> <code>/closingDays.add</code> <code>closingDays.add</code> Adds a closing day for the account <code>client.call('closingDays.add')</code> <code>/closingDays.delete</code> <code>closingDays.delete</code> Removes a closing day for the account <code>client.call('closingDays.delete')</code> <code>/closingDays.list</code> <code>closingDays.list</code> Returns information about closing days of the account <code>client.call('closingDays.list')</code>"},{"location":"api-reference/generated-endpoints/#day-off-types","title":"Day Off Types","text":"<p>Day Off Types</p> Endpoint Summary Description <code>client.call()</code> <code>/dayOffTypes.create</code> <code>dayOffTypes.create</code> Create a new day off type <code>client.call('dayOffTypes.create')</code> <code>/dayOffTypes.delete</code> <code>dayOffTypes.delete</code> Delete a day off type <code>client.call('dayOffTypes.delete')</code> <code>/dayOffTypes.list</code> <code>dayOffTypes.list</code> Returns a list of day off types for the account <code>client.call('dayOffTypes.list')</code> <code>/dayOffTypes.update</code> <code>dayOffTypes.update</code> Update a day off type <code>client.call('dayOffTypes.update')</code>"},{"location":"api-reference/generated-endpoints/#days-off","title":"Days Off","text":"<p>Days Off</p> Endpoint Summary Description <code>client.call()</code> <code>/daysOff.bulkDelete</code> <code>daysOff.bulkDelete</code> Deletes a list of days off for the given user <code>client.call('daysOff.bulkDelete')</code> <code>/daysOff.import</code> <code>daysOff.import</code> Imports a list of days off for the given user <code>client.call('daysOff.import')</code>"},{"location":"api-reference/generated-endpoints/#contacts","title":"Contacts","text":"<p>Contacts are physical entities who are added to your CRM database. Contacts might be linked to one or more companies.</p> Endpoint Summary Description <code>client.call()</code> <code>/contacts.add</code> <code>contacts.add</code> Add a new contact <code>client.call('contacts.add')</code> <code>/contacts.delete</code> <code>contacts.delete</code> Delete a contact <code>client.call('contacts.delete')</code> <code>/contacts.info</code> <code>contacts.info</code> Get details for a single contact <code>client.call('contacts.info')</code> <code>/contacts.linkToCompany</code> <code>contacts.linkToCompany</code> Link a contact to a company <code>client.call('contacts.linkToCompany')</code> <code>/contacts.list</code> <code>contacts.list</code> Get a list of contacts <code>client.call('contacts.list')</code> <code>/contacts.tag</code> <code>contacts.tag</code> Add a new or existing tag to a contact <code>client.call('contacts.tag')</code> <code>/contacts.unlinkFromCompany</code> <code>contacts.unlinkFromCompany</code> Unlink a contact from a company <code>client.call('contacts.unlinkFromCompany')</code> <code>/contacts.untag</code> <code>contacts.untag</code> Remove a tag from a contact <code>client.call('contacts.untag')</code> <code>/contacts.update</code> <code>contacts.update</code> Update a contact <code>client.call('contacts.update')</code> <code>/contacts.updateCompanyLink</code> <code>contacts.updateCompanyLink</code> Update contact to company link <code>client.call('contacts.updateCompanyLink')</code> <code>/contacts.uploadAvatar</code> <code>contacts.uploadAvatar</code> Update the avatar of a contact <code>client.call('contacts.uploadAvatar')</code>"},{"location":"api-reference/generated-endpoints/#companies","title":"Companies","text":"<p>Companies are legal entities, usually linked to a VAT and/or local business number.</p> Endpoint Summary Description <code>client.call()</code> <code>/companies.add</code> <code>companies.add</code> Add a new company <code>client.call('companies.add')</code> <code>/companies.delete</code> <code>companies.delete</code> Delete a company <code>client.call('companies.delete')</code> <code>/companies.info</code> <code>companies.info</code> Get details for a single company <code>client.call('companies.info')</code> <code>/companies.list</code> <code>companies.list</code> Get a list of companies <code>client.call('companies.list')</code> <code>/companies.tag</code> <code>companies.tag</code> Add a new or existing tag to a company <code>client.call('companies.tag')</code> <code>/companies.untag</code> <code>companies.untag</code> Remove a tag from a company <code>client.call('companies.untag')</code> <code>/companies.update</code> <code>companies.update</code> Update a company <code>client.call('companies.update')</code> <code>/companies.uploadLogo</code> <code>companies.uploadLogo</code> Update the logo of a company <code>client.call('companies.uploadLogo')</code>"},{"location":"api-reference/generated-endpoints/#business-types","title":"Business Types","text":"<p>Each country has a specific set of business types or range of legal entities. You can specify the business type when adding or updating a company.</p> Endpoint Summary Description <code>client.call()</code> <code>/businessTypes.list</code> <code>businessTypes.list</code> Get the names of business types (legal structures) a company can have within a certain country, sorted alphabetically <code>client.call('businessTypes.list')</code>"},{"location":"api-reference/generated-endpoints/#tags","title":"Tags","text":"<p>Tags are used to label contacts or companies, so that they can easily be filtered or grouped into segments.</p> Endpoint Summary Description <code>client.call()</code> <code>/tags.list</code> <code>tags.list</code> Get a list of tags <code>client.call('tags.list')</code>"},{"location":"api-reference/generated-endpoints/#addresses","title":"Addresses","text":"<p>We provide a set of data which can be used to build addresses.</p> Endpoint Summary Description <code>client.call()</code> <code>/levelTwoAreas.list</code> <code>levelTwoAreas.list</code> Get a list of level two areas (which correspond to provinces, departments or states in most countries) <code>client.call('levelTwoAreas.list')</code>"},{"location":"api-reference/generated-endpoints/#deals","title":"Deals","text":"<p>Deals are sale opportunities, which need to be followed up by their responsible user. A deal can move through specific deal phases, and be marked as won or lost.</p> Endpoint Summary Description <code>client.call()</code> <code>/deals.create</code> <code>deals.create</code> Create a new deal for a customer <code>client.call('deals.create')</code> <code>/deals.delete</code> <code>deals.delete</code> Delete a deal <code>client.call('deals.delete')</code> <code>/deals.info</code> <code>deals.info</code> Get details for a single deal <code>client.call('deals.info')</code> <code>/deals.list</code> <code>deals.list</code> Get a list of deals <code>client.call('deals.list')</code> <code>/deals.lose</code> <code>deals.lose</code> Mark a deal as lost <code>client.call('deals.lose')</code> <code>/deals.move</code> <code>deals.move</code> Move the deal to a different phase <code>client.call('deals.move')</code> <code>/deals.update</code> <code>deals.update</code> Update a deal <code>client.call('deals.update')</code> <code>/deals.win</code> <code>deals.win</code> Mark a deal as won <code>client.call('deals.win')</code> <code>/lostReasons.list</code> <code>lostReasons.list</code> Get a list of lost reasons for deals <code>client.call('lostReasons.list')</code>"},{"location":"api-reference/generated-endpoints/#deal-pipelines","title":"Deal Pipelines","text":"<p>Each deal belongs to a specific pipeline, in which it goes through the different deal phases.</p> Endpoint Summary Description <code>client.call()</code> <code>/dealPipelines.create</code> <code>dealPipelines.create</code> Create a new deal pipeline <code>client.call('dealPipelines.create')</code> <code>/dealPipelines.delete</code> <code>dealPipelines.delete</code> Delete a deal pipeline <code>client.call('dealPipelines.delete')</code> <code>/dealPipelines.duplicate</code> <code>dealPipelines.duplicate</code> Create a new deal pipeline by duplicating an existing one <code>client.call('dealPipelines.duplicate')</code> <code>/dealPipelines.list</code> <code>dealPipelines.list</code> Get a list of all deal pipelines <code>client.call('dealPipelines.list')</code> <code>/dealPipelines.markAsDefault</code> <code>dealPipelines.markAsDefault</code> Mark a pipeline as default <code>client.call('dealPipelines.markAsDefault')</code> <code>/dealPipelines.update</code> <code>dealPipelines.update</code> Update a single deal pipeline <code>client.call('dealPipelines.update')</code>"},{"location":"api-reference/generated-endpoints/#deal-phases","title":"Deal Phases","text":"<p>Deal phases are the different phases a deal typically goes through. A deal can be moved to either a next or previous phase. A deal can be marked as won or lost independently from the deal phase.</p> Endpoint Summary Description <code>client.call()</code> <code>/dealPhases.create</code> <code>dealPhases.create</code> Create a new deal phase <code>client.call('dealPhases.create')</code> <code>/dealPhases.delete</code> <code>dealPhases.delete</code> Delete a phase <code>client.call('dealPhases.delete')</code> <code>/dealPhases.duplicate</code> <code>dealPhases.duplicate</code> Create a new deal phase by duplicating an existing one <code>client.call('dealPhases.duplicate')</code> <code>/dealPhases.list</code> <code>dealPhases.list</code> Get a list of all phases a deal can go through, sorted by their order in the flow <code>client.call('dealPhases.list')</code> <code>/dealPhases.move</code> <code>dealPhases.move</code> Move a phase to a new position in the pipeline <code>client.call('dealPhases.move')</code> <code>/dealPhases.update</code> <code>dealPhases.update</code> Update a deal phase <code>client.call('dealPhases.update')</code>"},{"location":"api-reference/generated-endpoints/#deal-sources","title":"Deal Sources","text":"<p>Deal sources are used to track the origin of a deal.</p> Endpoint Summary Description <code>client.call()</code> <code>/dealSources.list</code> <code>dealSources.list</code> Get a list of all deal sources, sorted alphabetically (on name) <code>client.call('dealSources.list')</code>"},{"location":"api-reference/generated-endpoints/#quotations","title":"Quotations","text":"<p>A quotation is a sales offer for a specific customer. It is always attached to a deal. Quotations can be signed online via Cloudsign.</p> Endpoint Summary Description <code>client.call()</code> <code>/quotations.accept</code> <code>quotations.accept</code> Mark a quotation as accepted <code>client.call('quotations.accept')</code> <code>/quotations.create</code> <code>quotations.create</code> Create a quotation <code>client.call('quotations.create')</code> <code>/quotations.delete</code> <code>quotations.delete</code> Delete a quotation <code>client.call('quotations.delete')</code> <code>/quotations.download</code> <code>quotations.download</code> Download a quotation in a specific format <code>client.call('quotations.download')</code> <code>/quotations.info</code> <code>quotations.info</code> Get a quotation <code>client.call('quotations.info')</code> <code>/quotations.list</code> <code>quotations.list</code> Get a list of quotations <code>client.call('quotations.list')</code> <code>/quotations.send</code> <code>quotations.send</code> Send a quotation <code>client.call('quotations.send')</code> <code>/quotations.update</code> <code>quotations.update</code> Update a quotation <code>client.call('quotations.update')</code>"},{"location":"api-reference/generated-endpoints/#orders","title":"Orders","text":"Endpoint Summary Description <code>client.call()</code> <code>/orders.info</code> <code>orders.info</code> Get details for a single order <code>client.call('orders.info')</code> <code>/orders.list</code> <code>orders.list</code> Get a list of orders <code>client.call('orders.list')</code>"},{"location":"api-reference/generated-endpoints/#meetings","title":"Meetings","text":"<p>Meetings</p> Endpoint Summary Description <code>client.call()</code> <code>/meetings.complete</code> <code>meetings.complete</code> Mark a meeting as complete <code>client.call('meetings.complete')</code> <code>/meetings.createReport</code> <code>meetings.createReport</code> Creates a report for a meeting <code>client.call('meetings.createReport')</code> <code>/meetings.delete</code> <code>meetings.delete</code> Deletes a meeting <code>client.call('meetings.delete')</code> <code>/meetings.info</code> <code>meetings.info</code> Get information about a meeting <code>client.call('meetings.info')</code> <code>/meetings.list</code> <code>meetings.list</code> Get a list of meetings <code>client.call('meetings.list')</code> <code>/meetings.schedule</code> <code>meetings.schedule</code> Schedule a meeting <code>client.call('meetings.schedule')</code> <code>/meetings.update</code> <code>meetings.update</code> Update a meeting <code>client.call('meetings.update')</code>"},{"location":"api-reference/generated-endpoints/#calls","title":"Calls","text":"<p>Calls</p> Endpoint Summary Description <code>client.call()</code> <code>/calls.add</code> <code>calls.add</code> Add a new call <code>client.call('calls.add')</code> <code>/calls.complete</code> <code>calls.complete</code> Mark a call as complete <code>client.call('calls.complete')</code> <code>/calls.info</code> <code>calls.info</code> Get information about a call <code>client.call('calls.info')</code> <code>/calls.list</code> <code>calls.list</code> Get a list of calls <code>client.call('calls.list')</code> <code>/calls.update</code> <code>calls.update</code> Update a new call <code>client.call('calls.update')</code>"},{"location":"api-reference/generated-endpoints/#call-outcomes","title":"Call Outcomes","text":"<p>Call Outcomes</p> Endpoint Summary Description <code>client.call()</code> <code>/callOutcomes.list</code> <code>callOutcomes.list</code> Get a list of call outcomes <code>client.call('callOutcomes.list')</code>"},{"location":"api-reference/generated-endpoints/#calendar-events","title":"Calendar events","text":"<p>Calendar events are scheduled events in your calendar. A calendar event involves a particular activity type: a task, meeting or call.</p> Endpoint Summary Description <code>client.call()</code> <code>/events.cancel</code> <code>events.cancel</code> Cancel a calendar event (for all attendees) <code>client.call('events.cancel')</code> <code>/events.create</code> <code>events.create</code> Create a new calendar event <code>client.call('events.create')</code> <code>/events.info</code> <code>events.info</code> Get details for a single calendar event <code>client.call('events.info')</code> <code>/events.list</code> <code>events.list</code> Get a list of calendar events <code>client.call('events.list')</code> <code>/events.update</code> <code>events.update</code> Update a calendar event <code>client.call('events.update')</code>"},{"location":"api-reference/generated-endpoints/#activity-types","title":"Activity Types","text":"<p>Activity types identify the different types of events that take place within your organisation.</p> Endpoint Summary Description <code>client.call()</code> <code>/activityTypes.list</code> <code>activityTypes.list</code> Get a list of all activity types <code>client.call('activityTypes.list')</code>"},{"location":"api-reference/generated-endpoints/#invoices","title":"Invoices","text":"<p>Teamleader provides a whole set of endpoints to make it easy to develop</p> Endpoint Summary Description <code>client.call()</code> <code>/invoices.book</code> <code>invoices.book</code> Book a draft invoice <code>client.call('invoices.book')</code> <code>/invoices.copy</code> <code>invoices.copy</code> Creates a new draft invoice based on another invoice <code>client.call('invoices.copy')</code> <code>/invoices.credit</code> <code>invoices.credit</code> Credit an invoice completely <code>client.call('invoices.credit')</code> <code>/invoices.creditPartially</code> <code>invoices.creditPartially</code> Credit an invoice partially <code>client.call('invoices.creditPartially')</code> <code>/invoices.delete</code> <code>invoices.delete</code> Delete an existing invoice. Only possible for draft invoices or the last booked invoice <code>client.call('invoices.delete')</code> <code>/invoices.download</code> <code>invoices.download</code> Download an invoice in a specific format <code>client.call('invoices.download')</code> <code>/invoices.draft</code> <code>invoices.draft</code> Draft a new invoice <code>client.call('invoices.draft')</code> <code>/invoices.info</code> <code>invoices.info</code> Get details for a single invoice <code>client.call('invoices.info')</code> <code>/invoices.list</code> <code>invoices.list</code> Get a list of invoices <code>client.call('invoices.list')</code> <code>/invoices.registerPayment</code> <code>invoices.registerPayment</code> Register a payment for an invoice <code>client.call('invoices.registerPayment')</code> <code>/invoices.removePayments</code> <code>invoices.removePayments</code> Marks an invoice as unpaid and removes all linked payments. This will also trigger a re-rendering of the invoice PDF <code>client.call('invoices.removePayments')</code> <code>/invoices.send</code> <code>invoices.send</code> Send an invoice via e-mail <code>client.call('invoices.send')</code> <code>/invoices.sendViaPeppol</code> <code>invoices.sendViaPeppol</code> Send an invoice via the Peppol network <code>client.call('invoices.sendViaPeppol')</code> <code>/invoices.update</code> <code>invoices.update</code> Update a draft invoice. Booked invoices cannot be updated <code>client.call('invoices.update')</code> <code>/invoices.updateBooked</code> <code>invoices.updateBooked</code> Update a booked invoice. Only available when editing booked invoices is allowed through the settings <code>client.call('invoices.updateBooked')</code>"},{"location":"api-reference/generated-endpoints/#credit-notes","title":"Credit Notes","text":"<p>Credit notes are created when certain products or services are not delivered</p> Endpoint Summary Description <code>client.call()</code> <code>/creditNotes.download</code> <code>creditNotes.download</code> Download a credit note in a specific format <code>client.call('creditNotes.download')</code> <code>/creditNotes.info</code> <code>creditNotes.info</code> Get details for a single credit note <code>client.call('creditNotes.info')</code> <code>/creditNotes.list</code> <code>creditNotes.list</code> List credit notes <code>client.call('creditNotes.list')</code> <code>/creditNotes.sendViaPeppol</code> <code>creditNotes.sendViaPeppol</code> Send a credit note via the Peppol network <code>client.call('creditNotes.sendViaPeppol')</code>"},{"location":"api-reference/generated-endpoints/#subscriptions","title":"Subscriptions","text":"<p>Subscriptions</p> Endpoint Summary Description <code>client.call()</code> <code>/subscriptions.create</code> <code>subscriptions.create</code> Create a new subscription <code>client.call('subscriptions.create')</code> <code>/subscriptions.deactivate</code> <code>subscriptions.deactivate</code> Deactivate a subscription <code>client.call('subscriptions.deactivate')</code> <code>/subscriptions.info</code> <code>subscriptions.info</code> Get details for a single subscription <code>client.call('subscriptions.info')</code> <code>/subscriptions.list</code> <code>subscriptions.list</code> Get a list of subscriptions <code>client.call('subscriptions.list')</code> <code>/subscriptions.update</code> <code>subscriptions.update</code> Update a subscription <code>client.call('subscriptions.update')</code>"},{"location":"api-reference/generated-endpoints/#tax-rates","title":"Tax Rates","text":"<p>Tax rates provide an overview of different taxation rates used to bill</p> Endpoint Summary Description <code>client.call()</code> <code>/taxRates.list</code> <code>taxRates.list</code> Get a list of available tax rates <code>client.call('taxRates.list')</code>"},{"location":"api-reference/generated-endpoints/#payment-terms","title":"Payment Terms","text":"<p>Payment terms are the conditions under which an invoice need to be paid.</p> Endpoint Summary Description <code>client.call()</code> <code>/paymentTerms.list</code> <code>paymentTerms.list</code> Get a list of available payment terms <code>client.call('paymentTerms.list')</code>"},{"location":"api-reference/generated-endpoints/#withholding-tax-rates","title":"Withholding Tax Rates","text":"<p>Withholding tax rates provide an overview of different taxation rates used</p> Endpoint Summary Description <code>client.call()</code> <code>/withholdingTaxRates.list</code> <code>withholdingTaxRates.list</code> Get a list of available withholding tax rates <code>client.call('withholdingTaxRates.list')</code>"},{"location":"api-reference/generated-endpoints/#commercial-discounts","title":"Commercial Discounts","text":"<p>Commercial Discounts</p> Endpoint Summary Description <code>client.call()</code> <code>/commercialDiscounts.list</code> <code>commercialDiscounts.list</code> Get a list of commercial discounts <code>client.call('commercialDiscounts.list')</code>"},{"location":"api-reference/generated-endpoints/#payment-methods","title":"Payment Methods","text":"<p>Payment Methods</p> Endpoint Summary Description <code>client.call()</code> <code>/paymentMethods.list</code> <code>paymentMethods.list</code> Get a list of payment methods <code>client.call('paymentMethods.list')</code>"},{"location":"api-reference/generated-endpoints/#expenses","title":"Expenses","text":"<p>Expenses</p> Endpoint Summary Description <code>client.call()</code> <code>/expenses.list</code> <code>expenses.list</code> Get a list of all expenses <code>client.call('expenses.list')</code>"},{"location":"api-reference/generated-endpoints/#bookkeeping-submissions","title":"Bookkeeping Submissions","text":"<p>Bookkeeping Submissions</p> Endpoint Summary Description <code>client.call()</code> <code>/bookkeepingSubmissions.list</code> <code>bookkeepingSubmissions.list</code> List all bookkeeping submissions belonging to a specific financial document id and type <code>client.call('bookkeepingSubmissions.list')</code>"},{"location":"api-reference/generated-endpoints/#incoming-credit-notes","title":"Incoming Credit Notes","text":"<p>Incoming credit notes are credit notes received from your suppliers. They</p> Endpoint Summary Description <code>client.call()</code> <code>/incomingCreditNotes.add</code> <code>incomingCreditNotes.add</code> Adds an incoming credit note <code>client.call('incomingCreditNotes.add')</code> <code>/incomingCreditNotes.approve</code> <code>incomingCreditNotes.approve</code> Approve an incoming credit note <code>client.call('incomingCreditNotes.approve')</code> <code>/incomingCreditNotes.delete</code> <code>incomingCreditNotes.delete</code> Deletes an incoming credit note <code>client.call('incomingCreditNotes.delete')</code> <code>/incomingCreditNotes.info</code> <code>incomingCreditNotes.info</code> Get details for a single incoming credit note <code>client.call('incomingCreditNotes.info')</code> <code>/incomingCreditNotes.listPayments</code> <code>incomingCreditNotes.listPayments</code> List payments for an incoming credit note <code>client.call('incomingCreditNotes.listPayments')</code> <code>/incomingCreditNotes.markAsPendingReview</code> <code>incomingCreditNotes.markAsPendingReview</code> Mark an incoming credit note as pending review <code>client.call('incomingCreditNotes.markAsPendingReview')</code> <code>/incomingCreditNotes.refuse</code> <code>incomingCreditNotes.refuse</code> Refuse an incoming credit note <code>client.call('incomingCreditNotes.refuse')</code> <code>/incomingCreditNotes.registerPayment</code> <code>incomingCreditNotes.registerPayment</code> Register a payment for an incoming credit note <code>client.call('incomingCreditNotes.registerPayment')</code> <code>/incomingCreditNotes.removePayment</code> <code>incomingCreditNotes.removePayment</code> Remove a payment from an incoming credit note <code>client.call('incomingCreditNotes.removePayment')</code> <code>/incomingCreditNotes.sendToBookkeeping</code> <code>incomingCreditNotes.sendToBookkeeping</code> Send an incoming credit note to bookkeeping <code>client.call('incomingCreditNotes.sendToBookkeeping')</code> <code>/incomingCreditNotes.update</code> <code>incomingCreditNotes.update</code> Updates an incoming credit note <code>client.call('incomingCreditNotes.update')</code> <code>/incomingCreditNotes.updatePayment</code> <code>incomingCreditNotes.updatePayment</code> Update a payment for an incoming credit note <code>client.call('incomingCreditNotes.updatePayment')</code>"},{"location":"api-reference/generated-endpoints/#incoming-invoices","title":"Incoming Invoices","text":"<p>Incoming invoices are invoices received from your suppliers. They can be</p> Endpoint Summary Description <code>client.call()</code> <code>/incomingInvoices.add</code> <code>incomingInvoices.add</code> Adds an incoming invoice <code>client.call('incomingInvoices.add')</code> <code>/incomingInvoices.approve</code> <code>incomingInvoices.approve</code> Approve an incoming invoice <code>client.call('incomingInvoices.approve')</code> <code>/incomingInvoices.delete</code> <code>incomingInvoices.delete</code> Deletes an incoming invoice <code>client.call('incomingInvoices.delete')</code> <code>/incomingInvoices.info</code> <code>incomingInvoices.info</code> Get details for a single incoming invoice <code>client.call('incomingInvoices.info')</code> <code>/incomingInvoices.listPayments</code> <code>incomingInvoices.listPayments</code> List payments for an incoming invoice <code>client.call('incomingInvoices.listPayments')</code> <code>/incomingInvoices.markAsPendingReview</code> <code>incomingInvoices.markAsPendingReview</code> Mark an incoming invoice as pending review <code>client.call('incomingInvoices.markAsPendingReview')</code> <code>/incomingInvoices.refuse</code> <code>incomingInvoices.refuse</code> Refuse an incoming invoice <code>client.call('incomingInvoices.refuse')</code> <code>/incomingInvoices.registerPayment</code> <code>incomingInvoices.registerPayment</code> Register a payment for an incoming invoice <code>client.call('incomingInvoices.registerPayment')</code> <code>/incomingInvoices.removePayment</code> <code>incomingInvoices.removePayment</code> Remove a payment from an incoming invoice <code>client.call('incomingInvoices.removePayment')</code> <code>/incomingInvoices.sendToBookkeeping</code> <code>incomingInvoices.sendToBookkeeping</code> Send an incoming invoice to bookkeeping <code>client.call('incomingInvoices.sendToBookkeeping')</code> <code>/incomingInvoices.update</code> <code>incomingInvoices.update</code> Updates an incoming invoice <code>client.call('incomingInvoices.update')</code> <code>/incomingInvoices.updatePayment</code> <code>incomingInvoices.updatePayment</code> Update a payment for an incoming invoice <code>client.call('incomingInvoices.updatePayment')</code>"},{"location":"api-reference/generated-endpoints/#receipts","title":"Receipts","text":"<p>Receipts are expenses for which you have a receipt, but no invoice. They can</p> Endpoint Summary Description <code>client.call()</code> <code>/receipts.add</code> <code>receipts.add</code> Adds a receipt <code>client.call('receipts.add')</code> <code>/receipts.approve</code> <code>receipts.approve</code> Approve a receipt <code>client.call('receipts.approve')</code> <code>/receipts.delete</code> <code>receipts.delete</code> Deletes a receipt <code>client.call('receipts.delete')</code> <code>/receipts.info</code> <code>receipts.info</code> Get details for a single receipt <code>client.call('receipts.info')</code> <code>/receipts.listPayments</code> <code>receipts.listPayments</code> List payments for a(n incoming) receipt <code>client.call('receipts.listPayments')</code> <code>/receipts.markAsPendingReview</code> <code>receipts.markAsPendingReview</code> Mark a receipts as pending review <code>client.call('receipts.markAsPendingReview')</code> <code>/receipts.refuse</code> <code>receipts.refuse</code> Refuse a receipts <code>client.call('receipts.refuse')</code> <code>/receipts.registerPayment</code> <code>receipts.registerPayment</code> Register a payment for a(n incoming) receipt <code>client.call('receipts.registerPayment')</code> <code>/receipts.removePayment</code> <code>receipts.removePayment</code> Remove a payment from a receipt <code>client.call('receipts.removePayment')</code> <code>/receipts.sendToBookkeeping</code> <code>receipts.sendToBookkeeping</code> Send a receipt to bookkeeping for processing <code>client.call('receipts.sendToBookkeeping')</code> <code>/receipts.update</code> <code>receipts.update</code> Updates a receipt <code>client.call('receipts.update')</code> <code>/receipts.updatePayment</code> <code>receipts.updatePayment</code> Update a payment for a(n incoming) receipt <code>client.call('receipts.updatePayment')</code>"},{"location":"api-reference/generated-endpoints/#product-categories","title":"Product Categories","text":"<p>Product categories are used to group specific products. They can be linked</p> Endpoint Summary Description <code>client.call()</code> <code>/productCategories.list</code> <code>productCategories.list</code> Get a list of product categories <code>client.call('productCategories.list')</code>"},{"location":"api-reference/generated-endpoints/#products","title":"Products","text":"Endpoint Summary Description <code>client.call()</code> <code>/products.add</code> <code>products.add</code> Add a new product <code>client.call('products.add')</code> <code>/products.delete</code> <code>products.delete</code> Delete a product <code>client.call('products.delete')</code> <code>/products.info</code> <code>products.info</code> Get details for a single product <code>client.call('products.info')</code> <code>/products.list</code> <code>products.list</code> Get a list of products <code>client.call('products.list')</code> <code>/products.update</code> <code>products.update</code> Update a product <code>client.call('products.update')</code>"},{"location":"api-reference/generated-endpoints/#units-of-measure","title":"Units of Measure","text":"<p>Units of Measure</p> Endpoint Summary Description <code>client.call()</code> <code>/unitsOfMeasure.list</code> <code>unitsOfMeasure.list</code> Get a list of units of measure <code>client.call('unitsOfMeasure.list')</code>"},{"location":"api-reference/generated-endpoints/#price-lists","title":"Price Lists","text":"<p>Price Lists</p> Endpoint Summary Description <code>client.call()</code> <code>/priceLists.list</code> <code>priceLists.list</code> Get a list of priceLists <code>client.call('priceLists.list')</code>"},{"location":"api-reference/generated-endpoints/#legacy-projects","title":"Legacy Projects","text":"<p>Projects allow users to work together as a team on a single project. They</p> Endpoint Summary Description <code>client.call()</code> <code>/projects.addParticipant</code> <code>projects.addParticipant</code> Add a participant to a project <code>client.call('projects.addParticipant')</code> <code>/projects.close</code> <code>projects.close</code> Closes a project, all its phases, and all tasks within each phase (but not meetings) <code>client.call('projects.close')</code> <code>/projects.create</code> <code>projects.create</code> Create a new project <code>client.call('projects.create')</code> <code>/projects.delete</code> <code>projects.delete</code> Delete a project <code>client.call('projects.delete')</code> <code>/projects.info</code> <code>projects.info</code> Get details for a single project <code>client.call('projects.info')</code> <code>/projects.list</code> <code>projects.list</code> Get a list of projects <code>client.call('projects.list')</code> <code>/projects.reopen</code> <code>projects.reopen</code> Reopens a project, changing its status to \"active\" <code>client.call('projects.reopen')</code> <code>/projects.update</code> <code>projects.update</code> Update a project <code>client.call('projects.update')</code> <code>/projects.updateParticipant</code> <code>projects.updateParticipant</code> Update a participant's role for a project <code>client.call('projects.updateParticipant')</code>"},{"location":"api-reference/generated-endpoints/#legacy-milestones","title":"Legacy Milestones","text":"<p>Every projects consists of one or more milestones which are limited in time</p> Endpoint Summary Description <code>client.call()</code> <code>/milestones.close</code> <code>milestones.close</code> Close a milestone. All open tasks will be closed, open meetings will remain open. Closing the last open milestone will also close the project <code>client.call('milestones.close')</code> <code>/milestones.create</code> <code>milestones.create</code> Create a new milestone <code>client.call('milestones.create')</code> <code>/milestones.delete</code> <code>milestones.delete</code> Delete a milestone <code>client.call('milestones.delete')</code> <code>/milestones.info</code> <code>milestones.info</code> Get details for a single milestone <code>client.call('milestones.info')</code> <code>/milestones.list</code> <code>milestones.list</code> Get a list of project milestones <code>client.call('milestones.list')</code> <code>/milestones.open</code> <code>milestones.open</code> (Re)open a milestone. If the milestone's project is closed, the project will be reopened <code>client.call('milestones.open')</code> <code>/milestones.update</code> <code>milestones.update</code> Update a milestone <code>client.call('milestones.update')</code>"},{"location":"api-reference/generated-endpoints/#projects","title":"Projects","text":"<p>_This is the documentation of the new projects module. See the **Legacy</p> Endpoint Summary Description <code>client.call()</code> <code>/projects-v2/projects.addCustomer</code> <code>projects.addCustomer</code> Add a customer to the project. Doesn't fail if the customer was already added <code>client.call('projects-v2/projects.addCustomer')</code> <code>/projects-v2/projects.addDeal</code> <code>projects.addDeal</code> Add a deal to the project. Doesn't fail if the deal was already added <code>client.call('projects-v2/projects.addDeal')</code> <code>/projects-v2/projects.addOwner</code> <code>projects.addOwner</code> Add a user as owner. Doesn't fail if the user was already added <code>client.call('projects-v2/projects.addOwner')</code> <code>/projects-v2/projects.addQuotation</code> <code>projects.addQuotation</code> Add a quotation to the project. Doesn't fail if the quotation was already added <code>client.call('projects-v2/projects.addQuotation')</code> <code>/projects-v2/projects.assign</code> <code>projects.assign</code> Assign a user or a team to a project <code>client.call('projects-v2/projects.assign')</code> <code>/projects-v2/projects.close</code> <code>projects.close</code> Mark a project as closed <code>client.call('projects-v2/projects.close')</code> <code>/projects-v2/projects.create</code> <code>projects.create</code> Create a new project. Only <code>title</code> is required. All the other fields are optional <code>client.call('projects-v2/projects.create')</code> <code>/projects-v2/projects.delete</code> <code>projects.delete</code> Delete a project <code>client.call('projects-v2/projects.delete')</code> <code>/projects-v2/projects.duplicate</code> <code>projects.duplicate</code> Duplicate a project <code>client.call('projects-v2/projects.duplicate')</code> <code>/projects-v2/projects.info</code> <code>projects.info</code> Returns all the information of a single project <code>client.call('projects-v2/projects.info')</code> <code>/projects-v2/projects.list</code> <code>projects.list</code> Lists all projects that match the optional filters provided <code>client.call('projects-v2/projects.list')</code> <code>/projects-v2/projects.removeCustomer</code> <code>projects.removeCustomer</code> Remove a customer from the project. Doesn't fail if the customer was not added <code>client.call('projects-v2/projects.removeCustomer')</code> <code>/projects-v2/projects.removeDeal</code> <code>projects.removeDeal</code> Remove a deal from the project. Doesn't fail if the deal was already removed <code>client.call('projects-v2/projects.removeDeal')</code> <code>/projects-v2/projects.removeOwner</code> <code>projects.removeOwner</code> Remove a user as owner. Doesn't fail if the user wasn't linked <code>client.call('projects-v2/projects.removeOwner')</code> <code>/projects-v2/projects.removeQuotation</code> <code>projects.removeQuotation</code> Remove a quotation from the project. Doesn't fail if the quotation was already removed <code>client.call('projects-v2/projects.removeQuotation')</code> <code>/projects-v2/projects.reopen</code> <code>projects.reopen</code> Reopen a closed project <code>client.call('projects-v2/projects.reopen')</code> <code>/projects-v2/projects.unassign</code> <code>projects.unassign</code> Unassign a user or a team from a project <code>client.call('projects-v2/projects.unassign')</code> <code>/projects-v2/projects.update</code> <code>projects.update</code> Update a project. All attributes except for <code>id</code> are optional. Providing <code>null</code> will clear that value from the project (for properties that are nullable) <code>client.call('projects-v2/projects.update')</code>"},{"location":"api-reference/generated-endpoints/#external-parties","title":"External parties","text":"<p>An external party is a contact or company that is added to a project with an optional function and/or sub function.</p> Endpoint Summary Description <code>client.call()</code> <code>/projects-v2/externalParties.addToProject</code> <code>externalParties.addToProject</code> Add an external party to a project <code>client.call('projects-v2/externalParties.addToProject')</code> <code>/projects-v2/externalParties.delete</code> <code>externalParties.delete</code> Delete an external party <code>client.call('projects-v2/externalParties.delete')</code> <code>/projects-v2/externalParties.update</code> <code>externalParties.update</code> Update an external party <code>client.call('projects-v2/externalParties.update')</code>"},{"location":"api-reference/generated-endpoints/#project-lines","title":"Project lines","text":"<p>A project line can be a group, a task, or a material.</p> Endpoint Summary Description <code>client.call()</code> <code>/projects-v2/projectLines.addToGroup</code> <code>projectLines.addToGroup</code> Add an existing task or material to a group <code>client.call('projects-v2/projectLines.addToGroup')</code> <code>/projects-v2/projectLines.list</code> <code>projectLines.list</code> All line types (tasks, materials, groups) can be side-loaded <code>client.call('projects-v2/projectLines.list')</code> <code>/projects-v2/projectLines.removeFromGroup</code> <code>projectLines.removeFromGroup</code> Remove a task or material from the group it is currently in <code>client.call('projects-v2/projectLines.removeFromGroup')</code>"},{"location":"api-reference/generated-endpoints/#groups","title":"Groups","text":"Endpoint Summary Description <code>client.call()</code> <code>/projects-v2/projectGroups.assign</code> <code>projectGroups.assign</code> Assign a user or a team to a group <code>client.call('projects-v2/projectGroups.assign')</code> <code>/projects-v2/projectGroups.create</code> <code>projectGroups.create</code> Create a group. All properties except for <code>title</code> and <code>project_id</code> are optional <code>client.call('projects-v2/projectGroups.create')</code> <code>/projects-v2/projectGroups.delete</code> <code>projectGroups.delete</code> Delete a group <code>client.call('projects-v2/projectGroups.delete')</code> <code>/projects-v2/projectGroups.duplicate</code> <code>projectGroups.duplicate</code> Duplicate a group and its entities, without any time trackings <code>client.call('projects-v2/projectGroups.duplicate')</code> <code>/projects-v2/projectGroups.info</code> <code>projectGroups.info</code> Returns all the information for one group <code>client.call('projects-v2/projectGroups.info')</code> <code>/projects-v2/projectGroups.list</code> <code>projectGroups.list</code> Lists all the groups that match the optional filters provided <code>client.call('projects-v2/projectGroups.list')</code> <code>/projects-v2/projectGroups.unassign</code> <code>projectGroups.unassign</code> Unassign a user or a team from a group <code>client.call('projects-v2/projectGroups.unassign')</code> <code>/projects-v2/projectGroups.update</code> <code>projectGroups.update</code> Update a group. All attributes except for <code>id</code> are optional. Providing <code>null</code> will clear that value from the project (for properties that are nullable) <code>client.call('projects-v2/projectGroups.update')</code>"},{"location":"api-reference/generated-endpoints/#tasks","title":"Tasks","text":"<p>_These endpoints are for (new) project tasks. For documentation on</p> Endpoint Summary Description <code>client.call()</code> <code>/projects-v2/tasks.assign</code> <code>tasks.assign</code> Assign a user or a team to a task <code>client.call('projects-v2/tasks.assign')</code> <code>/projects-v2/tasks.create</code> <code>tasks.create</code> Create a task. All properties except for <code>title</code> and <code>project_id</code> are optional <code>client.call('projects-v2/tasks.create')</code> <code>/projects-v2/tasks.delete</code> <code>tasks.delete</code> Delete a task <code>client.call('projects-v2/tasks.delete')</code> <code>/projects-v2/tasks.duplicate</code> <code>tasks.duplicate</code> Duplicate a task, without its time trackings <code>client.call('projects-v2/tasks.duplicate')</code> <code>/projects-v2/tasks.info</code> <code>tasks.info</code> Returns all the information for one task <code>client.call('projects-v2/tasks.info')</code> <code>/projects-v2/tasks.list</code> <code>tasks.list</code> Lists all the tasks that match the optional filters provided <code>client.call('projects-v2/tasks.list')</code> <code>/projects-v2/tasks.unassign</code> <code>tasks.unassign</code> Unassign a user or a team from a task <code>client.call('projects-v2/tasks.unassign')</code> <code>/projects-v2/tasks.update</code> <code>tasks.update</code> Update a task. All attributes except for <code>id</code> are optional. Providing <code>null</code> will clear that value from the project (for properties that are nullable) <code>client.call('projects-v2/tasks.update')</code>"},{"location":"api-reference/generated-endpoints/#materials","title":"Materials","text":"Endpoint Summary Description <code>client.call()</code> <code>/projects-v2/materials.assign</code> <code>materials.assign</code> Assign a user or a team to a material <code>client.call('projects-v2/materials.assign')</code> <code>/projects-v2/materials.create</code> <code>materials.create</code> Create a material. All properties except for <code>title</code> and <code>project_id</code> are optional <code>client.call('projects-v2/materials.create')</code> <code>/projects-v2/materials.delete</code> <code>materials.delete</code> Delete a material <code>client.call('projects-v2/materials.delete')</code> <code>/projects-v2/materials.duplicate</code> <code>materials.duplicate</code> Duplicate a material <code>client.call('projects-v2/materials.duplicate')</code> <code>/projects-v2/materials.info</code> <code>materials.info</code> Returns all the information for one material <code>client.call('projects-v2/materials.info')</code> <code>/projects-v2/materials.list</code> <code>materials.list</code> Lists all the materials that match the optional filters provided <code>client.call('projects-v2/materials.list')</code> <code>/projects-v2/materials.unassign</code> <code>materials.unassign</code> Unassign a user or a team from a material <code>client.call('projects-v2/materials.unassign')</code> <code>/projects-v2/materials.update</code> <code>materials.update</code> Update a material. All attributes except for <code>id</code> are optional. Providing <code>null</code> will clear that value from the project (for properties that are nullable) <code>client.call('projects-v2/materials.update')</code>"},{"location":"api-reference/generated-endpoints/#tasks_1","title":"Tasks","text":"<p>Tasks</p> Endpoint Summary Description <code>client.call()</code> <code>/tasks.complete</code> <code>tasks.complete</code> Mark a task as complete <code>client.call('tasks.complete')</code> <code>/tasks.create</code> <code>tasks.create</code> Create a new task <code>client.call('tasks.create')</code> <code>/tasks.delete</code> <code>tasks.delete</code> Delete a task <code>client.call('tasks.delete')</code> <code>/tasks.info</code> <code>tasks.info</code> Get information about a task <code>client.call('tasks.info')</code> <code>/tasks.list</code> <code>tasks.list</code> Get a list of tasks <code>client.call('tasks.list')</code> <code>/tasks.reopen</code> <code>tasks.reopen</code> Reopen a task that had been marked as complete <code>client.call('tasks.reopen')</code> <code>/tasks.schedule</code> <code>tasks.schedule</code> Schedule a task in your calendar <code>client.call('tasks.schedule')</code> <code>/tasks.update</code> <code>tasks.update</code> Update a task <code>client.call('tasks.update')</code>"},{"location":"api-reference/generated-endpoints/#time-tracking","title":"Time Tracking","text":"<p>Time tracking allows users to record time spent on tasks or projects and the</p> Endpoint Summary Description <code>client.call()</code> <code>/timeTracking.add</code> <code>timeTracking.add</code> Add tracked time <code>client.call('timeTracking.add')</code> <code>/timeTracking.delete</code> <code>timeTracking.delete</code> Delete a tracked time <code>client.call('timeTracking.delete')</code> <code>/timeTracking.info</code> <code>timeTracking.info</code> Get information about tracked time <code>client.call('timeTracking.info')</code> <code>/timeTracking.list</code> <code>timeTracking.list</code> Get a list of tracked time <code>client.call('timeTracking.list')</code> <code>/timeTracking.resume</code> <code>timeTracking.resume</code> Start a new timer based on previously tracked time <code>client.call('timeTracking.resume')</code> <code>/timeTracking.update</code> <code>timeTracking.update</code> Update tracked time <code>client.call('timeTracking.update')</code>"},{"location":"api-reference/generated-endpoints/#timers","title":"Timers","text":"<p>Timers are an easy way to track time. You can start, stop or resume a timer</p> Endpoint Summary Description <code>client.call()</code> <code>/timers.current</code> <code>timers.current</code> Get the current running timer <code>client.call('timers.current')</code> <code>/timers.start</code> <code>timers.start</code> Start a new timer <code>client.call('timers.start')</code> <code>/timers.stop</code> <code>timers.stop</code> Stop the current timer. This will add a new time tracking in the background <code>client.call('timers.stop')</code> <code>/timers.update</code> <code>timers.update</code> Update the current timer. Only possible if there is a timer running <code>client.call('timers.update')</code>"},{"location":"api-reference/generated-endpoints/#tickets","title":"Tickets","text":"Endpoint Summary Description <code>client.call()</code> <code>/tickets.addInternalMessage</code> <code>tickets.addInternalMessage</code> Adds an internal message to a ticket <code>client.call('tickets.addInternalMessage')</code> <code>/tickets.addReply</code> <code>tickets.addReply</code> Adds a message to a ticket <code>client.call('tickets.addReply')</code> <code>/tickets.create</code> <code>tickets.create</code> Create a ticket <code>client.call('tickets.create')</code> <code>/tickets.getMessage</code> <code>tickets.getMessage</code> Gets the ticket message <code>client.call('tickets.getMessage')</code> <code>/tickets.importMessage</code> <code>tickets.importMessage</code> Imports an existing message to a ticket <code>client.call('tickets.importMessage')</code> <code>/tickets.info</code> <code>tickets.info</code> Get details for a single ticket <code>client.call('tickets.info')</code> <code>/tickets.list</code> <code>tickets.list</code> Get a list of tickets <code>client.call('tickets.list')</code> <code>/tickets.listMessages</code> <code>tickets.listMessages</code> Lists messages of a ticket <code>client.call('tickets.listMessages')</code> <code>/tickets.update</code> <code>tickets.update</code> Update a ticket <code>client.call('tickets.update')</code>"},{"location":"api-reference/generated-endpoints/#ticket-status","title":"Ticket Status","text":"<p>Ticket Status</p> Endpoint Summary Description <code>client.call()</code> <code>/ticketStatus.list</code> <code>ticketStatus.list</code> Get a list of ticket statuses <code>client.call('ticketStatus.list')</code>"},{"location":"api-reference/generated-endpoints/#files","title":"Files","text":"<p>Files</p> Endpoint Summary Description <code>client.call()</code> <code>/files.delete</code> <code>files.delete</code> Delete a file <code>client.call('files.delete')</code> <code>/files.download</code> <code>files.download</code> Request the download link for a file <code>client.call('files.download')</code> <code>/files.info</code> <code>files.info</code> Get details for a single file <code>client.call('files.info')</code> <code>/files.list</code> <code>files.list</code> Get a list of files <code>client.call('files.list')</code> <code>/files.upload</code> <code>files.upload</code> Request the upload link for a file <code>client.call('files.upload')</code>"},{"location":"api-reference/generated-endpoints/#mail-templates","title":"Mail Templates","text":"<p>Mail Templates</p> Endpoint Summary Description <code>client.call()</code> <code>/mailTemplates.list</code> <code>mailTemplates.list</code> Get a list of all mail templates <code>client.call('mailTemplates.list')</code>"},{"location":"api-reference/generated-endpoints/#migrating","title":"Migrating","text":"<p>\u26a0\ufe0f WARNING! These endpoints are not guaranteed to stay backwards compatible.</p> Endpoint Summary Description <code>client.call()</code> <code>/migrate.activityType</code> <code>migrate.activityType</code> Translates <code>meeting</code>, <code>call</code> and <code>task</code> into their respective activity type UUID <code>client.call('migrate.activityType')</code> <code>/migrate.id</code> <code>migrate.id</code> Translates an ID from the deprecated API into a new UUID <code>client.call('migrate.id')</code> <code>/migrate.taxRate</code> <code>migrate.taxRate</code> Translates tax rates from the deprecated API into a new UUID tax rate <code>client.call('migrate.taxRate')</code>"},{"location":"api-reference/generated-endpoints/#webhooks","title":"Webhooks","text":"<p>Webhooks</p> Endpoint Summary Description <code>client.call()</code> <code>/webhooks.list</code> <code>webhooks.list</code> List registered webhooks ordered by URL <code>client.call('webhooks.list')</code> <code>/webhooks.register</code> <code>webhooks.register</code> Register a new webhook <code>client.call('webhooks.register')</code> <code>/webhooks.unregister</code> <code>webhooks.unregister</code> Unregister a webhook <code>client.call('webhooks.unregister')</code>"},{"location":"api-reference/generated-endpoints/#cloud-platforms","title":"Cloud Platforms","text":"<p>Cloud Platforms</p> Endpoint Summary Description <code>client.call()</code> <code>/cloudPlatforms.url</code> <code>cloudPlatforms.url</code> Fetch cloudPlatform url for type and id <code>client.call('cloudPlatforms.url')</code>"},{"location":"api-reference/generated-endpoints/#accounts","title":"Accounts","text":"<p>Accounts</p> Endpoint Summary Description <code>client.call()</code> <code>/accounts.projects-v2-status</code> <code>accounts.projects-v2-status</code> Fetch which version of Projects the account is using <code>client.call('accounts.projects-v2-status')</code>"},{"location":"api-reference/generated-endpoints/#plannable-items","title":"Plannable items","text":"<p>Plannable items</p> Endpoint Summary Description <code>client.call()</code> <code>/plannableItems.info</code> <code>plannableItems.info</code> Returns the info for a single plannable item, either by ID or source if the ID is unknown <code>client.call('plannableItems.info')</code> <code>/plannableItems.list</code> <code>plannableItems.list</code> Lists all plannable items that match the optional filters provided <code>client.call('plannableItems.list')</code>"},{"location":"api-reference/generated-endpoints/#reservations","title":"Reservations","text":"<p>Reservations</p> Endpoint Summary Description <code>client.call()</code> <code>/reservations.create</code> <code>reservations.create</code> Create a new reservation <code>client.call('reservations.create')</code> <code>/reservations.delete</code> <code>reservations.delete</code> Delete a reservation <code>client.call('reservations.delete')</code> <code>/reservations.list</code> <code>reservations.list</code> Lists all reservations that match the optional filters provided <code>client.call('reservations.list')</code> <code>/reservations.update</code> <code>reservations.update</code> Update an existing reservation <code>client.call('reservations.update')</code>"},{"location":"api-reference/generated-endpoints/#user-availability","title":"User availability","text":"<p>User availability</p> Endpoint Summary Description <code>client.call()</code> <code>/userAvailability.daily</code> <code>userAvailability.daily</code> Returns the daily availability for all users <code>client.call('userAvailability.daily')</code> <code>/userAvailability.total</code> <code>userAvailability.total</code> Returns the total availability for all users <code>client.call('userAvailability.total')</code>"},{"location":"api-reference/models/","title":"Models \u2014 API Reference","text":"<p>Curated model classes with full type hints, <code>from_api()</code> deserialisation, and computed properties.  All models are pure dataclasses (no Pydantic / attrs).</p>"},{"location":"api-reference/models/#common-sub-models","title":"Common sub-models","text":"<p>These sub-models are shared across multiple resource models.</p>"},{"location":"api-reference/models/#teamleader.models.common.TypeAndId","title":"TypeAndId  <code>dataclass</code>","text":"<p>A lightweight reference: a resource type string plus a UUID.</p> Source code in <code>teamleader/models/common.py</code> <pre><code>@dataclass\nclass TypeAndId:\n    \"\"\"A lightweight reference: a resource type string plus a UUID.\"\"\"\n\n    id: str = \"\"\n    type: str = \"\"\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        return cls(\n            id=data.get(\"id\", \"\"),\n            type=data.get(\"type\", \"\"),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return {\"id\": self.id, \"type\": self.type}\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.common.Address","title":"Address  <code>dataclass</code>","text":"<p>Postal address (leaf object \u2014 no type/addressee here).</p> Source code in <code>teamleader/models/common.py</code> <pre><code>@dataclass\nclass Address:\n    \"\"\"Postal address (leaf object \u2014 no type/addressee here).\"\"\"\n\n    line_1: str | None = None\n    postal_code: str | None = None\n    city: str | None = None\n    country: str | None = None  # ISO 3166-1 alpha-2\n    area_level_two: dict[str, Any] | None = None  # TypeAndId ref (id + type)\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        area = data.get(\"area_level_two\")\n        return cls(\n            line_1=data.get(\"line_1\"),\n            postal_code=data.get(\"postal_code\"),\n            city=data.get(\"city\"),\n            country=data.get(\"country\"),\n            area_level_two=area if area else None,\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        out: dict[str, Any] = {}\n        if self.line_1 is not None:\n            out[\"line_1\"] = self.line_1\n        if self.postal_code is not None:\n            out[\"postal_code\"] = self.postal_code\n        if self.city is not None:\n            out[\"city\"] = self.city\n        if self.country is not None:\n            out[\"country\"] = self.country\n        if self.area_level_two is not None:\n            out[\"area_level_two\"] = self.area_level_two\n        return out\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.common.AddressEntry","title":"AddressEntry  <code>dataclass</code>","text":"<p>Typed address wrapper \u2014 role (e.g. \"primary\") + address + optional addressee.</p> Source code in <code>teamleader/models/common.py</code> <pre><code>@dataclass\nclass AddressEntry:\n    \"\"\"Typed address wrapper \u2014 role (e.g. \"primary\") + address + optional addressee.\"\"\"\n\n    type: str | None = None       # \"primary\" | \"invoicing\" | \"delivery\" | \"visiting\"\n    address: Address | None = None\n    addressee: str | None = None\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        raw_addr = data.get(\"address\") or {}\n        addressee = raw_addr.get(\"addressee\")\n        addr = Address.from_api(raw_addr) if raw_addr else None\n        return cls(\n            type=data.get(\"type\"),\n            address=addr,\n            addressee=addressee,\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        out: dict[str, Any] = {}\n        if self.type is not None:\n            out[\"type\"] = self.type\n        addr_dict: dict[str, Any] = self.address.to_dict() if self.address else {}\n        if self.addressee is not None:\n            addr_dict[\"addressee\"] = self.addressee\n        if addr_dict:\n            out[\"address\"] = addr_dict\n        return out\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.common.Email","title":"Email  <code>dataclass</code>","text":"<p>Email contact detail.</p> Source code in <code>teamleader/models/common.py</code> <pre><code>@dataclass\nclass Email:\n    \"\"\"Email contact detail.\"\"\"\n\n    email: str = \"\"\n    type: str | None = None  # \"primary\" | \"invoicing\"\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        return cls(\n            email=data.get(\"email\", \"\"),\n            type=data.get(\"type\"),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        out: dict[str, Any] = {\"email\": self.email}\n        if self.type is not None:\n            out[\"type\"] = self.type\n        return out\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.common.Telephone","title":"Telephone  <code>dataclass</code>","text":"<p>Telephone contact detail.</p> Source code in <code>teamleader/models/common.py</code> <pre><code>@dataclass\nclass Telephone:\n    \"\"\"Telephone contact detail.\"\"\"\n\n    number: str = \"\"\n    type: str | None = None  # \"phone\" | \"mobile\" | \"fax\"\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        return cls(\n            number=data.get(\"number\", \"\"),\n            type=data.get(\"type\"),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        out: dict[str, Any] = {\"number\": self.number}\n        if self.type is not None:\n            out[\"type\"] = self.type\n        return out\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.common.Money","title":"Money  <code>dataclass</code>","text":"<p>Monetary amount with ISO 4217 currency code.</p> Source code in <code>teamleader/models/common.py</code> <pre><code>@dataclass\nclass Money:\n    \"\"\"Monetary amount with ISO 4217 currency code.\"\"\"\n\n    amount: float = 0.0\n    currency: str = \"\"  # e.g. \"EUR\"\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        return cls(\n            amount=float(data.get(\"amount\", 0.0)),\n            currency=data.get(\"currency\", \"\"),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return {\"amount\": self.amount, \"currency\": self.currency}\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.common.CustomField","title":"CustomField  <code>dataclass</code>","text":"<p>A single custom field value attached to a resource.</p> <p><code>id</code> is the custom-field definition UUID (shortcut to <code>definition[\"id\"]</code>).</p> Source code in <code>teamleader/models/common.py</code> <pre><code>@dataclass\nclass CustomField:\n    \"\"\"A single custom field value attached to a resource.\n\n    ``id`` is the custom-field *definition* UUID (shortcut to ``definition[\"id\"]``).\n    \"\"\"\n\n    id: str = \"\"\n    value: Any = None\n    definition: dict[str, Any] = field(default_factory=dict)\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        definition = data.get(\"definition\") or {}\n        return cls(\n            id=definition.get(\"id\", \"\"),\n            value=data.get(\"value\"),\n            definition=definition,\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return {\n            \"definition\": self.definition or {\"id\": self.id, \"type\": \"customFieldDefinition\"},\n            \"value\": self.value,\n        }\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.common.PaymentTerm","title":"PaymentTerm  <code>dataclass</code>","text":"<p>Payment term attached to a contact or company.</p> Source code in <code>teamleader/models/common.py</code> <pre><code>@dataclass\nclass PaymentTerm:\n    \"\"\"Payment term attached to a contact or company.\"\"\"\n\n    type: str = \"\"  # \"cash\" | \"end_of_month\" | \"after_invoice_date\"\n    days: int | None = None\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        return cls(\n            type=data.get(\"type\", \"\"),\n            days=int(data[\"days\"]) if data.get(\"days\") is not None else None,\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        out: dict[str, Any] = {\"type\": self.type}\n        if self.days is not None:\n            out[\"days\"] = self.days\n        return out\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.common.WebLink","title":"WebLink  <code>dataclass</code>","text":"<p>Web URL attached to a resource (kept for backward compatibility).</p> Source code in <code>teamleader/models/common.py</code> <pre><code>@dataclass\nclass WebLink:\n    \"\"\"Web URL attached to a resource (kept for backward compatibility).\"\"\"\n\n    url: str = \"\"\n    type: str | None = None\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        return cls(\n            url=data.get(\"url\", \"\"),\n            type=data.get(\"type\"),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        out: dict[str, Any] = {\"url\": self.url}\n        if self.type is not None:\n            out[\"type\"] = self.type\n        return out\n</code></pre>"},{"location":"api-reference/models/#contact","title":"Contact","text":""},{"location":"api-reference/models/#teamleader.models.contact.Contact","title":"Contact  <code>dataclass</code>","text":"<p>Represents a Teamleader Focus contact.</p> <p>All datetime fields are ISO 8601 strings as returned by the API. Use the computed properties for convenient access to common values.</p> Source code in <code>teamleader/models/contact.py</code> <pre><code>@dataclass\nclass Contact:\n    \"\"\"Represents a Teamleader Focus contact.\n\n    All datetime fields are ISO 8601 strings as returned by the API.\n    Use the computed properties for convenient access to common values.\n    \"\"\"\n\n    id: str = \"\"\n    first_name: str = \"\"\n    last_name: str = \"\"\n    status: str = \"active\"                          # \"active\" | \"deactivated\"\n    salutation: str | None = None\n    vat_number: str | None = None\n    emails: list[Email] = field(default_factory=list)\n    telephones: list[Telephone] = field(default_factory=list)\n    website: str | None = None                      # single URL string (spec: `website`)\n    addresses: list[AddressEntry] = field(default_factory=list)\n    gender: str | None = None\n    birthdate: str | None = None                    # ISO 8601 date\n    iban: str | None = None\n    bic: str | None = None\n    national_identification_number: str | None = None\n    companies: list[dict[str, Any]] = field(default_factory=list)\n    language: str | None = None                     # ISO 639-1\n    payment_term: PaymentTerm | None = None\n    remarks: str | None = None                      # Markdown\n    tags: list[str] = field(default_factory=list)\n    custom_fields: list[CustomField] = field(default_factory=list)\n    marketing_mails_consent: bool | None = None\n    added_at: str | None = None                     # ISO 8601 datetime\n    updated_at: str | None = None                   # ISO 8601 datetime\n    web_url: str | None = None\n\n    # ------------------------------------------------------------------\n    # Computed properties\n    # ------------------------------------------------------------------\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Return ``\"First Last\"``, stripping extra whitespace.\"\"\"\n        return f\"{self.first_name} {self.last_name}\".strip()\n\n    @property\n    def primary_email(self) -&gt; str | None:\n        \"\"\"Return the address marked ``type=\"primary\"``, else the first email, else ``None``.\"\"\"\n        for e in self.emails:\n            if e.type == \"primary\":\n                return e.email\n        return self.emails[0].email if self.emails else None\n\n    @property\n    def primary_phone(self) -&gt; str | None:\n        \"\"\"Return the first telephone number, or ``None`` if none recorded.\"\"\"\n        return self.telephones[0].number if self.telephones else None\n\n    @property\n    def is_active(self) -&gt; bool:\n        \"\"\"Return ``True`` when ``status == \"active\"``.\"\"\"\n        return self.status == \"active\"\n\n    # ------------------------------------------------------------------\n    # Serialisation\n    # ------------------------------------------------------------------\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        \"\"\"Deserialise from a ``contacts.info`` or ``contacts.list`` payload.\n\n        Accepts both the full response wrapper ``{\"data\": {...}}`` and a bare\n        data dict.\n        \"\"\"\n        d = data.get(\"data\", data)\n\n        pt_raw = d.get(\"payment_term\")\n        payment_term = PaymentTerm.from_api(pt_raw) if pt_raw else None\n\n        return cls(\n            id=d.get(\"id\", \"\"),\n            first_name=d.get(\"first_name\", \"\"),\n            last_name=d.get(\"last_name\", \"\"),\n            status=d.get(\"status\", \"active\"),\n            salutation=d.get(\"salutation\"),\n            vat_number=d.get(\"vat_number\"),\n            emails=[Email.from_api(e) for e in d.get(\"emails\", [])],\n            telephones=[Telephone.from_api(t) for t in d.get(\"telephones\", [])],\n            website=d.get(\"website\"),\n            addresses=[AddressEntry.from_api(a) for a in d.get(\"addresses\", [])],\n            gender=d.get(\"gender\"),\n            birthdate=d.get(\"birthdate\"),\n            iban=d.get(\"iban\"),\n            bic=d.get(\"bic\"),\n            national_identification_number=d.get(\"national_identification_number\"),\n            companies=d.get(\"companies\", []),\n            language=d.get(\"language\"),\n            payment_term=payment_term,\n            remarks=d.get(\"remarks\"),\n            tags=d.get(\"tags\", []),\n            custom_fields=[CustomField.from_api(cf) for cf in d.get(\"custom_fields\", [])],\n            marketing_mails_consent=d.get(\"marketing_mails_consent\"),\n            added_at=d.get(\"added_at\"),\n            updated_at=d.get(\"updated_at\"),\n            web_url=d.get(\"web_url\"),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialise to the shape expected by ``contacts.add`` / ``contacts.update``.\"\"\"\n        out: dict[str, Any] = {\n            \"id\": self.id,\n            \"first_name\": self.first_name,\n            \"last_name\": self.last_name,\n            \"status\": self.status,\n            \"emails\": [e.to_dict() for e in self.emails],\n            \"telephones\": [t.to_dict() for t in self.telephones],\n            \"addresses\": [a.to_dict() for a in self.addresses],\n            \"tags\": self.tags,\n            \"custom_fields\": [cf.to_dict() for cf in self.custom_fields],\n            \"companies\": self.companies,\n        }\n        if self.salutation is not None:\n            out[\"salutation\"] = self.salutation\n        if self.vat_number is not None:\n            out[\"vat_number\"] = self.vat_number\n        if self.website is not None:\n            out[\"website\"] = self.website\n        if self.gender is not None:\n            out[\"gender\"] = self.gender\n        if self.birthdate is not None:\n            out[\"birthdate\"] = self.birthdate\n        if self.iban is not None:\n            out[\"iban\"] = self.iban\n        if self.bic is not None:\n            out[\"bic\"] = self.bic\n        if self.national_identification_number is not None:\n            out[\"national_identification_number\"] = self.national_identification_number\n        if self.language is not None:\n            out[\"language\"] = self.language\n        if self.payment_term is not None:\n            out[\"payment_term\"] = self.payment_term.to_dict()\n        if self.remarks is not None:\n            out[\"remarks\"] = self.remarks\n        if self.marketing_mails_consent is not None:\n            out[\"marketing_mails_consent\"] = self.marketing_mails_consent\n        return out\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.contact.Contact.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Return <code>\"First Last\"</code>, stripping extra whitespace.</p>"},{"location":"api-reference/models/#teamleader.models.contact.Contact.primary_email","title":"primary_email  <code>property</code>","text":"<pre><code>primary_email: str | None\n</code></pre> <p>Return the address marked <code>type=\"primary\"</code>, else the first email, else <code>None</code>.</p>"},{"location":"api-reference/models/#teamleader.models.contact.Contact.primary_phone","title":"primary_phone  <code>property</code>","text":"<pre><code>primary_phone: str | None\n</code></pre> <p>Return the first telephone number, or <code>None</code> if none recorded.</p>"},{"location":"api-reference/models/#teamleader.models.contact.Contact.is_active","title":"is_active  <code>property</code>","text":"<pre><code>is_active: bool\n</code></pre> <p>Return <code>True</code> when <code>status == \"active\"</code>.</p>"},{"location":"api-reference/models/#teamleader.models.contact.Contact.from_api","title":"from_api  <code>classmethod</code>","text":"<pre><code>from_api(data: dict[str, Any]) -&gt; Self\n</code></pre> <p>Deserialise from a <code>contacts.info</code> or <code>contacts.list</code> payload.</p> <p>Accepts both the full response wrapper <code>{\"data\": {...}}</code> and a bare data dict.</p> Source code in <code>teamleader/models/contact.py</code> <pre><code>@classmethod\ndef from_api(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"Deserialise from a ``contacts.info`` or ``contacts.list`` payload.\n\n    Accepts both the full response wrapper ``{\"data\": {...}}`` and a bare\n    data dict.\n    \"\"\"\n    d = data.get(\"data\", data)\n\n    pt_raw = d.get(\"payment_term\")\n    payment_term = PaymentTerm.from_api(pt_raw) if pt_raw else None\n\n    return cls(\n        id=d.get(\"id\", \"\"),\n        first_name=d.get(\"first_name\", \"\"),\n        last_name=d.get(\"last_name\", \"\"),\n        status=d.get(\"status\", \"active\"),\n        salutation=d.get(\"salutation\"),\n        vat_number=d.get(\"vat_number\"),\n        emails=[Email.from_api(e) for e in d.get(\"emails\", [])],\n        telephones=[Telephone.from_api(t) for t in d.get(\"telephones\", [])],\n        website=d.get(\"website\"),\n        addresses=[AddressEntry.from_api(a) for a in d.get(\"addresses\", [])],\n        gender=d.get(\"gender\"),\n        birthdate=d.get(\"birthdate\"),\n        iban=d.get(\"iban\"),\n        bic=d.get(\"bic\"),\n        national_identification_number=d.get(\"national_identification_number\"),\n        companies=d.get(\"companies\", []),\n        language=d.get(\"language\"),\n        payment_term=payment_term,\n        remarks=d.get(\"remarks\"),\n        tags=d.get(\"tags\", []),\n        custom_fields=[CustomField.from_api(cf) for cf in d.get(\"custom_fields\", [])],\n        marketing_mails_consent=d.get(\"marketing_mails_consent\"),\n        added_at=d.get(\"added_at\"),\n        updated_at=d.get(\"updated_at\"),\n        web_url=d.get(\"web_url\"),\n    )\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.contact.Contact.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Serialise to the shape expected by <code>contacts.add</code> / <code>contacts.update</code>.</p> Source code in <code>teamleader/models/contact.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialise to the shape expected by ``contacts.add`` / ``contacts.update``.\"\"\"\n    out: dict[str, Any] = {\n        \"id\": self.id,\n        \"first_name\": self.first_name,\n        \"last_name\": self.last_name,\n        \"status\": self.status,\n        \"emails\": [e.to_dict() for e in self.emails],\n        \"telephones\": [t.to_dict() for t in self.telephones],\n        \"addresses\": [a.to_dict() for a in self.addresses],\n        \"tags\": self.tags,\n        \"custom_fields\": [cf.to_dict() for cf in self.custom_fields],\n        \"companies\": self.companies,\n    }\n    if self.salutation is not None:\n        out[\"salutation\"] = self.salutation\n    if self.vat_number is not None:\n        out[\"vat_number\"] = self.vat_number\n    if self.website is not None:\n        out[\"website\"] = self.website\n    if self.gender is not None:\n        out[\"gender\"] = self.gender\n    if self.birthdate is not None:\n        out[\"birthdate\"] = self.birthdate\n    if self.iban is not None:\n        out[\"iban\"] = self.iban\n    if self.bic is not None:\n        out[\"bic\"] = self.bic\n    if self.national_identification_number is not None:\n        out[\"national_identification_number\"] = self.national_identification_number\n    if self.language is not None:\n        out[\"language\"] = self.language\n    if self.payment_term is not None:\n        out[\"payment_term\"] = self.payment_term.to_dict()\n    if self.remarks is not None:\n        out[\"remarks\"] = self.remarks\n    if self.marketing_mails_consent is not None:\n        out[\"marketing_mails_consent\"] = self.marketing_mails_consent\n    return out\n</code></pre>"},{"location":"api-reference/models/#company","title":"Company","text":""},{"location":"api-reference/models/#teamleader.models.company.Company","title":"Company  <code>dataclass</code>","text":"<p>Represents a Teamleader Focus company.</p> <p>All datetime fields are ISO 8601 strings as returned by the API. Use the computed properties for convenient access to common values.</p> Source code in <code>teamleader/models/company.py</code> <pre><code>@dataclass\nclass Company:\n    \"\"\"Represents a Teamleader Focus company.\n\n    All datetime fields are ISO 8601 strings as returned by the API.\n    Use the computed properties for convenient access to common values.\n    \"\"\"\n\n    id: str = \"\"\n    name: str = \"\"\n    status: str = \"active\"                          # \"active\" | \"deactivated\"\n    business_type: TypeAndId | None = None\n    vat_number: str | None = None\n    national_identification_number: str | None = None\n    emails: list[Email] = field(default_factory=list)\n    telephones: list[Telephone] = field(default_factory=list)\n    website: str | None = None                      # single URL string (spec: `website`)\n    addresses: list[AddressEntry] = field(default_factory=list)\n    iban: str | None = None\n    bic: str | None = None\n    language: str | None = None                     # ISO 639-1\n    preferred_currency: str | None = None           # ISO 4217\n    payment_term: PaymentTerm | None = None\n    responsible_user: TypeAndId | None = None\n    remarks: str | None = None                      # Markdown\n    tags: list[str] = field(default_factory=list)\n    custom_fields: list[CustomField] = field(default_factory=list)\n    marketing_mails_consent: bool | None = None\n    added_at: str | None = None                     # ISO 8601 datetime\n    updated_at: str | None = None                   # ISO 8601 datetime\n    web_url: str | None = None\n    # Only present when requested via `includes=related_companies`\n    related_companies: list[TypeAndId] = field(default_factory=list)\n    # Only present when requested via `includes=related_contacts`\n    related_contacts: list[dict[str, Any]] = field(default_factory=list)\n\n    # ------------------------------------------------------------------\n    # Computed properties\n    # ------------------------------------------------------------------\n\n    @property\n    def is_active(self) -&gt; bool:\n        \"\"\"Return ``True`` when ``status == \"active\"``.\"\"\"\n        return self.status == \"active\"\n\n    @property\n    def primary_email(self) -&gt; str | None:\n        \"\"\"Return the address marked ``type=\"primary\"``, else the first email, else ``None``.\"\"\"\n        for e in self.emails:\n            if e.type == \"primary\":\n                return e.email\n        return self.emails[0].email if self.emails else None\n\n    @property\n    def primary_phone(self) -&gt; str | None:\n        \"\"\"Return the first telephone number, or ``None`` if none recorded.\"\"\"\n        return self.telephones[0].number if self.telephones else None\n\n    # ------------------------------------------------------------------\n    # Serialisation\n    # ------------------------------------------------------------------\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        \"\"\"Deserialise from a ``companies.info`` or ``companies.list`` payload.\n\n        Accepts both the full response wrapper ``{\"data\": {...}}`` and a bare\n        data dict.\n        \"\"\"\n        d = data.get(\"data\", data)\n\n        bt_raw = d.get(\"business_type\")\n        business_type = TypeAndId.from_api(bt_raw) if bt_raw else None\n\n        ru_raw = d.get(\"responsible_user\")\n        responsible_user = TypeAndId.from_api(ru_raw) if ru_raw else None\n\n        pt_raw = d.get(\"payment_term\")\n        payment_term = PaymentTerm.from_api(pt_raw) if pt_raw else None\n\n        related_companies = [\n            TypeAndId.from_api(rc) for rc in d.get(\"related_companies\", [])\n        ]\n\n        return cls(\n            id=d.get(\"id\", \"\"),\n            name=d.get(\"name\", \"\"),\n            status=d.get(\"status\", \"active\"),\n            business_type=business_type,\n            vat_number=d.get(\"vat_number\"),\n            national_identification_number=d.get(\"national_identification_number\"),\n            emails=[Email.from_api(e) for e in d.get(\"emails\", [])],\n            telephones=[Telephone.from_api(t) for t in d.get(\"telephones\", [])],\n            website=d.get(\"website\"),\n            addresses=[AddressEntry.from_api(a) for a in d.get(\"addresses\", [])],\n            iban=d.get(\"iban\"),\n            bic=d.get(\"bic\"),\n            language=d.get(\"language\"),\n            preferred_currency=d.get(\"preferred_currency\"),\n            payment_term=payment_term,\n            responsible_user=responsible_user,\n            remarks=d.get(\"remarks\"),\n            tags=d.get(\"tags\", []),\n            custom_fields=[CustomField.from_api(cf) for cf in d.get(\"custom_fields\", [])],\n            marketing_mails_consent=d.get(\"marketing_mails_consent\"),\n            added_at=d.get(\"added_at\"),\n            updated_at=d.get(\"updated_at\"),\n            web_url=d.get(\"web_url\"),\n            related_companies=related_companies,\n            related_contacts=d.get(\"related_contacts\", []),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialise to the shape expected by ``companies.add`` / ``companies.update``.\"\"\"\n        out: dict[str, Any] = {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"status\": self.status,\n            \"emails\": [e.to_dict() for e in self.emails],\n            \"telephones\": [t.to_dict() for t in self.telephones],\n            \"addresses\": [a.to_dict() for a in self.addresses],\n            \"tags\": self.tags,\n            \"custom_fields\": [cf.to_dict() for cf in self.custom_fields],\n        }\n        if self.business_type is not None:\n            out[\"business_type\"] = self.business_type.to_dict()\n        if self.vat_number is not None:\n            out[\"vat_number\"] = self.vat_number\n        if self.national_identification_number is not None:\n            out[\"national_identification_number\"] = self.national_identification_number\n        if self.website is not None:\n            out[\"website\"] = self.website\n        if self.iban is not None:\n            out[\"iban\"] = self.iban\n        if self.bic is not None:\n            out[\"bic\"] = self.bic\n        if self.language is not None:\n            out[\"language\"] = self.language\n        if self.preferred_currency is not None:\n            out[\"preferred_currency\"] = self.preferred_currency\n        if self.payment_term is not None:\n            out[\"payment_term\"] = self.payment_term.to_dict()\n        if self.responsible_user is not None:\n            out[\"responsible_user\"] = self.responsible_user.to_dict()\n        if self.remarks is not None:\n            out[\"remarks\"] = self.remarks\n        if self.marketing_mails_consent is not None:\n            out[\"marketing_mails_consent\"] = self.marketing_mails_consent\n        return out\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.company.Company.is_active","title":"is_active  <code>property</code>","text":"<pre><code>is_active: bool\n</code></pre> <p>Return <code>True</code> when <code>status == \"active\"</code>.</p>"},{"location":"api-reference/models/#teamleader.models.company.Company.primary_email","title":"primary_email  <code>property</code>","text":"<pre><code>primary_email: str | None\n</code></pre> <p>Return the address marked <code>type=\"primary\"</code>, else the first email, else <code>None</code>.</p>"},{"location":"api-reference/models/#teamleader.models.company.Company.primary_phone","title":"primary_phone  <code>property</code>","text":"<pre><code>primary_phone: str | None\n</code></pre> <p>Return the first telephone number, or <code>None</code> if none recorded.</p>"},{"location":"api-reference/models/#teamleader.models.company.Company.from_api","title":"from_api  <code>classmethod</code>","text":"<pre><code>from_api(data: dict[str, Any]) -&gt; Self\n</code></pre> <p>Deserialise from a <code>companies.info</code> or <code>companies.list</code> payload.</p> <p>Accepts both the full response wrapper <code>{\"data\": {...}}</code> and a bare data dict.</p> Source code in <code>teamleader/models/company.py</code> <pre><code>@classmethod\ndef from_api(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"Deserialise from a ``companies.info`` or ``companies.list`` payload.\n\n    Accepts both the full response wrapper ``{\"data\": {...}}`` and a bare\n    data dict.\n    \"\"\"\n    d = data.get(\"data\", data)\n\n    bt_raw = d.get(\"business_type\")\n    business_type = TypeAndId.from_api(bt_raw) if bt_raw else None\n\n    ru_raw = d.get(\"responsible_user\")\n    responsible_user = TypeAndId.from_api(ru_raw) if ru_raw else None\n\n    pt_raw = d.get(\"payment_term\")\n    payment_term = PaymentTerm.from_api(pt_raw) if pt_raw else None\n\n    related_companies = [\n        TypeAndId.from_api(rc) for rc in d.get(\"related_companies\", [])\n    ]\n\n    return cls(\n        id=d.get(\"id\", \"\"),\n        name=d.get(\"name\", \"\"),\n        status=d.get(\"status\", \"active\"),\n        business_type=business_type,\n        vat_number=d.get(\"vat_number\"),\n        national_identification_number=d.get(\"national_identification_number\"),\n        emails=[Email.from_api(e) for e in d.get(\"emails\", [])],\n        telephones=[Telephone.from_api(t) for t in d.get(\"telephones\", [])],\n        website=d.get(\"website\"),\n        addresses=[AddressEntry.from_api(a) for a in d.get(\"addresses\", [])],\n        iban=d.get(\"iban\"),\n        bic=d.get(\"bic\"),\n        language=d.get(\"language\"),\n        preferred_currency=d.get(\"preferred_currency\"),\n        payment_term=payment_term,\n        responsible_user=responsible_user,\n        remarks=d.get(\"remarks\"),\n        tags=d.get(\"tags\", []),\n        custom_fields=[CustomField.from_api(cf) for cf in d.get(\"custom_fields\", [])],\n        marketing_mails_consent=d.get(\"marketing_mails_consent\"),\n        added_at=d.get(\"added_at\"),\n        updated_at=d.get(\"updated_at\"),\n        web_url=d.get(\"web_url\"),\n        related_companies=related_companies,\n        related_contacts=d.get(\"related_contacts\", []),\n    )\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.company.Company.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Serialise to the shape expected by <code>companies.add</code> / <code>companies.update</code>.</p> Source code in <code>teamleader/models/company.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialise to the shape expected by ``companies.add`` / ``companies.update``.\"\"\"\n    out: dict[str, Any] = {\n        \"id\": self.id,\n        \"name\": self.name,\n        \"status\": self.status,\n        \"emails\": [e.to_dict() for e in self.emails],\n        \"telephones\": [t.to_dict() for t in self.telephones],\n        \"addresses\": [a.to_dict() for a in self.addresses],\n        \"tags\": self.tags,\n        \"custom_fields\": [cf.to_dict() for cf in self.custom_fields],\n    }\n    if self.business_type is not None:\n        out[\"business_type\"] = self.business_type.to_dict()\n    if self.vat_number is not None:\n        out[\"vat_number\"] = self.vat_number\n    if self.national_identification_number is not None:\n        out[\"national_identification_number\"] = self.national_identification_number\n    if self.website is not None:\n        out[\"website\"] = self.website\n    if self.iban is not None:\n        out[\"iban\"] = self.iban\n    if self.bic is not None:\n        out[\"bic\"] = self.bic\n    if self.language is not None:\n        out[\"language\"] = self.language\n    if self.preferred_currency is not None:\n        out[\"preferred_currency\"] = self.preferred_currency\n    if self.payment_term is not None:\n        out[\"payment_term\"] = self.payment_term.to_dict()\n    if self.responsible_user is not None:\n        out[\"responsible_user\"] = self.responsible_user.to_dict()\n    if self.remarks is not None:\n        out[\"remarks\"] = self.remarks\n    if self.marketing_mails_consent is not None:\n        out[\"marketing_mails_consent\"] = self.marketing_mails_consent\n    return out\n</code></pre>"},{"location":"api-reference/models/#deal","title":"Deal","text":""},{"location":"api-reference/models/#teamleader.models.deal.Deal","title":"Deal  <code>dataclass</code>","text":"<p>Represents a Teamleader Focus deal.</p> <p>All datetime fields are ISO 8601 strings as returned by the API. Use the computed properties for convenient access to common values.</p> Source code in <code>teamleader/models/deal.py</code> <pre><code>@dataclass\nclass Deal:\n    \"\"\"Represents a Teamleader Focus deal.\n\n    All datetime fields are ISO 8601 strings as returned by the API.\n    Use the computed properties for convenient access to common values.\n    \"\"\"\n\n    id: str = \"\"\n    title: str = \"\"\n    summary: str | None = None\n    reference: str | None = None\n    status: str = \"open\"                        # \"open\" | \"won\" | \"lost\"\n    lead: dict[str, Any] | None = None          # {customer: TypeAndId, contact_person: TypeAndId}\n    department: TypeAndId | None = None\n    estimated_value: Money | None = None\n    estimated_closing_date: str | None = None   # ISO 8601 date\n    estimated_probability: float | None = None  # 0.0 \u2013 1.0\n    weighted_value: Money | None = None\n    purchase_order_number: str | None = None\n    current_phase: TypeAndId | None = None\n    responsible_user: TypeAndId | None = None\n    closed_at: str | None = None                # ISO 8601 datetime\n    source: TypeAndId | None = None\n    phase_history: list[dict[str, Any]] = field(default_factory=list)\n    quotations: list[TypeAndId] = field(default_factory=list)\n    lost_reason: dict[str, Any] | None = None\n    pipeline: TypeAndId | None = None\n    custom_fields: list[CustomField] = field(default_factory=list)\n    created_at: str | None = None               # ISO 8601 datetime\n    updated_at: str | None = None               # ISO 8601 datetime\n    web_url: str | None = None\n\n    # ------------------------------------------------------------------\n    # Computed properties\n    # ------------------------------------------------------------------\n\n    @property\n    def is_open(self) -&gt; bool:\n        \"\"\"Return ``True`` when the deal is still open.\"\"\"\n        return self.status == \"open\"\n\n    @property\n    def is_won(self) -&gt; bool:\n        \"\"\"Return ``True`` when the deal has been won.\"\"\"\n        return self.status == \"won\"\n\n    @property\n    def is_lost(self) -&gt; bool:\n        \"\"\"Return ``True`` when the deal has been lost.\"\"\"\n        return self.status == \"lost\"\n\n    @property\n    def customer_id(self) -&gt; str | None:\n        \"\"\"Return the UUID of the lead's customer, or ``None`` if no lead.\"\"\"\n        if self.lead and isinstance(self.lead.get(\"customer\"), dict):\n            return self.lead[\"customer\"].get(\"id\")\n        return None\n\n    @property\n    def customer_type(self) -&gt; str | None:\n        \"\"\"Return the resource type of the lead's customer (``\"contact\"`` or ``\"company\"``).\n\n        Returns ``None`` if no lead is set.\n        \"\"\"\n        if self.lead and isinstance(self.lead.get(\"customer\"), dict):\n            return self.lead[\"customer\"].get(\"type\")\n        return None\n\n    # ------------------------------------------------------------------\n    # Serialisation\n    # ------------------------------------------------------------------\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        \"\"\"Deserialise from a ``deals.info`` or ``deals.list`` payload.\n\n        Accepts both the full response wrapper ``{\"data\": {...}}`` and a bare\n        data dict.\n        \"\"\"\n        d = data.get(\"data\", data)\n\n        dept_raw = d.get(\"department\")\n        department = TypeAndId.from_api(dept_raw) if dept_raw else None\n\n        ev_raw = d.get(\"estimated_value\")\n        estimated_value = Money.from_api(ev_raw) if ev_raw else None\n\n        wv_raw = d.get(\"weighted_value\")\n        weighted_value = Money.from_api(wv_raw) if wv_raw else None\n\n        cp_raw = d.get(\"current_phase\")\n        current_phase = TypeAndId.from_api(cp_raw) if cp_raw else None\n\n        ru_raw = d.get(\"responsible_user\")\n        responsible_user = TypeAndId.from_api(ru_raw) if ru_raw else None\n\n        src_raw = d.get(\"source\")\n        source = TypeAndId.from_api(src_raw) if src_raw else None\n\n        pl_raw = d.get(\"pipeline\")\n        pipeline = TypeAndId.from_api(pl_raw) if pl_raw else None\n\n        quotations = [\n            TypeAndId.from_api(q) for q in d.get(\"quotations\", [])\n        ]\n\n        return cls(\n            id=d.get(\"id\", \"\"),\n            title=d.get(\"title\", \"\"),\n            summary=d.get(\"summary\"),\n            reference=d.get(\"reference\"),\n            status=d.get(\"status\", \"open\"),\n            lead=d.get(\"lead\"),\n            department=department,\n            estimated_value=estimated_value,\n            estimated_closing_date=d.get(\"estimated_closing_date\"),\n            estimated_probability=d.get(\"estimated_probability\"),\n            weighted_value=weighted_value,\n            purchase_order_number=d.get(\"purchase_order_number\"),\n            current_phase=current_phase,\n            responsible_user=responsible_user,\n            closed_at=d.get(\"closed_at\"),\n            source=source,\n            phase_history=d.get(\"phase_history\", []),\n            quotations=quotations,\n            lost_reason=d.get(\"lost_reason\"),\n            pipeline=pipeline,\n            custom_fields=[CustomField.from_api(cf) for cf in d.get(\"custom_fields\", [])],\n            created_at=d.get(\"created_at\"),\n            updated_at=d.get(\"updated_at\"),\n            web_url=d.get(\"web_url\"),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialise to the shape expected by ``deals.create`` / ``deals.update``.\"\"\"\n        out: dict[str, Any] = {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"status\": self.status,\n            \"custom_fields\": [cf.to_dict() for cf in self.custom_fields],\n        }\n        if self.summary is not None:\n            out[\"summary\"] = self.summary\n        if self.reference is not None:\n            out[\"reference\"] = self.reference\n        if self.lead is not None:\n            out[\"lead\"] = self.lead\n        if self.department is not None:\n            out[\"department\"] = self.department.to_dict()\n        if self.estimated_value is not None:\n            out[\"estimated_value\"] = self.estimated_value.to_dict()\n        if self.estimated_closing_date is not None:\n            out[\"estimated_closing_date\"] = self.estimated_closing_date\n        if self.estimated_probability is not None:\n            out[\"estimated_probability\"] = self.estimated_probability\n        if self.purchase_order_number is not None:\n            out[\"purchase_order_number\"] = self.purchase_order_number\n        if self.current_phase is not None:\n            out[\"current_phase\"] = self.current_phase.to_dict()\n        if self.responsible_user is not None:\n            out[\"responsible_user\"] = self.responsible_user.to_dict()\n        if self.source is not None:\n            out[\"source\"] = self.source.to_dict()\n        return out\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.deal.Deal.is_open","title":"is_open  <code>property</code>","text":"<pre><code>is_open: bool\n</code></pre> <p>Return <code>True</code> when the deal is still open.</p>"},{"location":"api-reference/models/#teamleader.models.deal.Deal.is_won","title":"is_won  <code>property</code>","text":"<pre><code>is_won: bool\n</code></pre> <p>Return <code>True</code> when the deal has been won.</p>"},{"location":"api-reference/models/#teamleader.models.deal.Deal.is_lost","title":"is_lost  <code>property</code>","text":"<pre><code>is_lost: bool\n</code></pre> <p>Return <code>True</code> when the deal has been lost.</p>"},{"location":"api-reference/models/#teamleader.models.deal.Deal.customer_id","title":"customer_id  <code>property</code>","text":"<pre><code>customer_id: str | None\n</code></pre> <p>Return the UUID of the lead's customer, or <code>None</code> if no lead.</p>"},{"location":"api-reference/models/#teamleader.models.deal.Deal.customer_type","title":"customer_type  <code>property</code>","text":"<pre><code>customer_type: str | None\n</code></pre> <p>Return the resource type of the lead's customer (<code>\"contact\"</code> or <code>\"company\"</code>).</p> <p>Returns <code>None</code> if no lead is set.</p>"},{"location":"api-reference/models/#teamleader.models.deal.Deal.from_api","title":"from_api  <code>classmethod</code>","text":"<pre><code>from_api(data: dict[str, Any]) -&gt; Self\n</code></pre> <p>Deserialise from a <code>deals.info</code> or <code>deals.list</code> payload.</p> <p>Accepts both the full response wrapper <code>{\"data\": {...}}</code> and a bare data dict.</p> Source code in <code>teamleader/models/deal.py</code> <pre><code>@classmethod\ndef from_api(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"Deserialise from a ``deals.info`` or ``deals.list`` payload.\n\n    Accepts both the full response wrapper ``{\"data\": {...}}`` and a bare\n    data dict.\n    \"\"\"\n    d = data.get(\"data\", data)\n\n    dept_raw = d.get(\"department\")\n    department = TypeAndId.from_api(dept_raw) if dept_raw else None\n\n    ev_raw = d.get(\"estimated_value\")\n    estimated_value = Money.from_api(ev_raw) if ev_raw else None\n\n    wv_raw = d.get(\"weighted_value\")\n    weighted_value = Money.from_api(wv_raw) if wv_raw else None\n\n    cp_raw = d.get(\"current_phase\")\n    current_phase = TypeAndId.from_api(cp_raw) if cp_raw else None\n\n    ru_raw = d.get(\"responsible_user\")\n    responsible_user = TypeAndId.from_api(ru_raw) if ru_raw else None\n\n    src_raw = d.get(\"source\")\n    source = TypeAndId.from_api(src_raw) if src_raw else None\n\n    pl_raw = d.get(\"pipeline\")\n    pipeline = TypeAndId.from_api(pl_raw) if pl_raw else None\n\n    quotations = [\n        TypeAndId.from_api(q) for q in d.get(\"quotations\", [])\n    ]\n\n    return cls(\n        id=d.get(\"id\", \"\"),\n        title=d.get(\"title\", \"\"),\n        summary=d.get(\"summary\"),\n        reference=d.get(\"reference\"),\n        status=d.get(\"status\", \"open\"),\n        lead=d.get(\"lead\"),\n        department=department,\n        estimated_value=estimated_value,\n        estimated_closing_date=d.get(\"estimated_closing_date\"),\n        estimated_probability=d.get(\"estimated_probability\"),\n        weighted_value=weighted_value,\n        purchase_order_number=d.get(\"purchase_order_number\"),\n        current_phase=current_phase,\n        responsible_user=responsible_user,\n        closed_at=d.get(\"closed_at\"),\n        source=source,\n        phase_history=d.get(\"phase_history\", []),\n        quotations=quotations,\n        lost_reason=d.get(\"lost_reason\"),\n        pipeline=pipeline,\n        custom_fields=[CustomField.from_api(cf) for cf in d.get(\"custom_fields\", [])],\n        created_at=d.get(\"created_at\"),\n        updated_at=d.get(\"updated_at\"),\n        web_url=d.get(\"web_url\"),\n    )\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.deal.Deal.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Serialise to the shape expected by <code>deals.create</code> / <code>deals.update</code>.</p> Source code in <code>teamleader/models/deal.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialise to the shape expected by ``deals.create`` / ``deals.update``.\"\"\"\n    out: dict[str, Any] = {\n        \"id\": self.id,\n        \"title\": self.title,\n        \"status\": self.status,\n        \"custom_fields\": [cf.to_dict() for cf in self.custom_fields],\n    }\n    if self.summary is not None:\n        out[\"summary\"] = self.summary\n    if self.reference is not None:\n        out[\"reference\"] = self.reference\n    if self.lead is not None:\n        out[\"lead\"] = self.lead\n    if self.department is not None:\n        out[\"department\"] = self.department.to_dict()\n    if self.estimated_value is not None:\n        out[\"estimated_value\"] = self.estimated_value.to_dict()\n    if self.estimated_closing_date is not None:\n        out[\"estimated_closing_date\"] = self.estimated_closing_date\n    if self.estimated_probability is not None:\n        out[\"estimated_probability\"] = self.estimated_probability\n    if self.purchase_order_number is not None:\n        out[\"purchase_order_number\"] = self.purchase_order_number\n    if self.current_phase is not None:\n        out[\"current_phase\"] = self.current_phase.to_dict()\n    if self.responsible_user is not None:\n        out[\"responsible_user\"] = self.responsible_user.to_dict()\n    if self.source is not None:\n        out[\"source\"] = self.source.to_dict()\n    return out\n</code></pre>"},{"location":"api-reference/models/#invoice","title":"Invoice","text":""},{"location":"api-reference/models/#teamleader.models.invoice.Invoice","title":"Invoice  <code>dataclass</code>","text":"<p>Represents a Teamleader Focus invoice.</p> <p>All date/datetime fields are ISO 8601 strings as returned by the API. Use the computed properties for convenient access to common values.</p> Source code in <code>teamleader/models/invoice.py</code> <pre><code>@dataclass\nclass Invoice:\n    \"\"\"Represents a Teamleader Focus invoice.\n\n    All date/datetime fields are ISO 8601 strings as returned by the API.\n    Use the computed properties for convenient access to common values.\n    \"\"\"\n\n    id: str = \"\"\n    department: TypeAndId | None = None\n    invoice_number: str | None = None\n    invoice_date: str | None = None             # ISO 8601 date (\"2016-02-04\")\n    status: str = \"draft\"                       # \"draft\" | \"outstanding\" | \"matched\"\n    due_on: str | None = None                   # ISO 8601 date (\"2016-03-03\")\n    paid: bool = False\n    paid_at: str | None = None                  # ISO 8601 datetime\n    sent: bool = False\n    purchase_order_number: str | None = None\n    invoicee: dict[str, Any] | None = None      # name, vat_number, customer TypeAndId, email, \u2026\n    discounts: list[dict[str, Any]] = field(default_factory=list)   # CommercialDiscount list\n    grouped_lines: list[dict[str, Any]] = field(default_factory=list)\n    total: dict[str, Any] | None = None         # tax_exclusive, tax_inclusive, payable, due, \u2026\n    payment_term: PaymentTerm | None = None\n    payments: list[dict[str, Any]] = field(default_factory=list)\n    payment_reference: str | None = None\n    note: str | None = None                     # plaintext\n    currency: str | None = None                 # ISO 4217\n    currency_exchange_rate: dict[str, Any] | None = None\n    deal: TypeAndId | None = None\n    custom_fields: list[CustomField] = field(default_factory=list)\n    created_at: str | None = None               # ISO 8601 datetime\n    updated_at: str | None = None               # ISO 8601 datetime\n    delivery_date: str | None = None            # ISO 8601 date\n\n    # ------------------------------------------------------------------\n    # Computed properties\n    # ------------------------------------------------------------------\n\n    @property\n    def is_paid(self) -&gt; bool:\n        \"\"\"Return ``True`` when the invoice has been marked paid.\"\"\"\n        return self.paid\n\n    @property\n    def is_draft(self) -&gt; bool:\n        \"\"\"Return ``True`` when the invoice is still a draft.\"\"\"\n        return self.status == \"draft\"\n\n    @property\n    def is_overdue(self) -&gt; bool:\n        \"\"\"Return ``True`` if the due date is in the past and the invoice is not paid.\n\n        Returns ``False`` if no ``due_on`` date is set or if it cannot be parsed.\n        \"\"\"\n        if self.paid or not self.due_on:\n            return False\n        try:\n            due = datetime.date.fromisoformat(self.due_on)\n        except ValueError:\n            return False\n        return due &lt; datetime.date.today()\n\n    @property\n    def total_due(self) -&gt; Money | None:\n        \"\"\"Return the outstanding ``due`` amount from the totals block, or ``None``.\"\"\"\n        if self.total and isinstance(self.total.get(\"due\"), dict):\n            return Money.from_api(self.total[\"due\"])\n        return None\n\n    @property\n    def customer_name(self) -&gt; str | None:\n        \"\"\"Return the invoicee name, or ``None`` if no invoicee is set.\"\"\"\n        if self.invoicee:\n            return self.invoicee.get(\"name\")\n        return None\n\n    # ------------------------------------------------------------------\n    # Serialisation\n    # ------------------------------------------------------------------\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        \"\"\"Deserialise from an ``invoices.info`` or ``invoices.list`` payload.\n\n        Accepts both the full response wrapper ``{\"data\": {...}}`` and a bare\n        data dict.\n        \"\"\"\n        d = data.get(\"data\", data)\n\n        dept_raw = d.get(\"department\")\n        department = TypeAndId.from_api(dept_raw) if dept_raw else None\n\n        pt_raw = d.get(\"payment_term\")\n        payment_term = PaymentTerm.from_api(pt_raw) if pt_raw else None\n\n        deal_raw = d.get(\"deal\")\n        deal = TypeAndId.from_api(deal_raw) if deal_raw else None\n\n        return cls(\n            id=d.get(\"id\", \"\"),\n            department=department,\n            invoice_number=d.get(\"invoice_number\"),\n            invoice_date=d.get(\"invoice_date\"),\n            status=d.get(\"status\", \"draft\"),\n            due_on=d.get(\"due_on\"),\n            paid=bool(d.get(\"paid\", False)),\n            paid_at=d.get(\"paid_at\"),\n            sent=bool(d.get(\"sent\", False)),\n            purchase_order_number=d.get(\"purchase_order_number\"),\n            invoicee=d.get(\"invoicee\"),\n            discounts=d.get(\"discounts\", []),\n            grouped_lines=d.get(\"grouped_lines\", []),\n            total=d.get(\"total\"),\n            payment_term=payment_term,\n            payments=d.get(\"payments\", []),\n            payment_reference=d.get(\"payment_reference\"),\n            note=d.get(\"note\"),\n            currency=d.get(\"currency\"),\n            currency_exchange_rate=d.get(\"currency_exchange_rate\"),\n            deal=deal,\n            custom_fields=[CustomField.from_api(cf) for cf in d.get(\"custom_fields\", [])],\n            created_at=d.get(\"created_at\"),\n            updated_at=d.get(\"updated_at\"),\n            delivery_date=d.get(\"delivery_date\"),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialise to the shape expected by invoice write endpoints.\"\"\"\n        out: dict[str, Any] = {\n            \"id\": self.id,\n            \"status\": self.status,\n            \"paid\": self.paid,\n            \"sent\": self.sent,\n            \"custom_fields\": [cf.to_dict() for cf in self.custom_fields],\n        }\n        if self.department is not None:\n            out[\"department\"] = self.department.to_dict()\n        if self.invoice_number is not None:\n            out[\"invoice_number\"] = self.invoice_number\n        if self.invoice_date is not None:\n            out[\"invoice_date\"] = self.invoice_date\n        if self.due_on is not None:\n            out[\"due_on\"] = self.due_on\n        if self.purchase_order_number is not None:\n            out[\"purchase_order_number\"] = self.purchase_order_number\n        if self.invoicee is not None:\n            out[\"invoicee\"] = self.invoicee\n        if self.discounts:\n            out[\"discounts\"] = self.discounts\n        if self.grouped_lines:\n            out[\"grouped_lines\"] = self.grouped_lines\n        if self.payment_term is not None:\n            out[\"payment_term\"] = self.payment_term.to_dict()\n        if self.payment_reference is not None:\n            out[\"payment_reference\"] = self.payment_reference\n        if self.note is not None:\n            out[\"note\"] = self.note\n        if self.currency is not None:\n            out[\"currency\"] = self.currency\n        if self.deal is not None:\n            out[\"deal\"] = self.deal.to_dict()\n        if self.delivery_date is not None:\n            out[\"delivery_date\"] = self.delivery_date\n        return out\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.invoice.Invoice.is_paid","title":"is_paid  <code>property</code>","text":"<pre><code>is_paid: bool\n</code></pre> <p>Return <code>True</code> when the invoice has been marked paid.</p>"},{"location":"api-reference/models/#teamleader.models.invoice.Invoice.is_draft","title":"is_draft  <code>property</code>","text":"<pre><code>is_draft: bool\n</code></pre> <p>Return <code>True</code> when the invoice is still a draft.</p>"},{"location":"api-reference/models/#teamleader.models.invoice.Invoice.is_overdue","title":"is_overdue  <code>property</code>","text":"<pre><code>is_overdue: bool\n</code></pre> <p>Return <code>True</code> if the due date is in the past and the invoice is not paid.</p> <p>Returns <code>False</code> if no <code>due_on</code> date is set or if it cannot be parsed.</p>"},{"location":"api-reference/models/#teamleader.models.invoice.Invoice.total_due","title":"total_due  <code>property</code>","text":"<pre><code>total_due: Money | None\n</code></pre> <p>Return the outstanding <code>due</code> amount from the totals block, or <code>None</code>.</p>"},{"location":"api-reference/models/#teamleader.models.invoice.Invoice.customer_name","title":"customer_name  <code>property</code>","text":"<pre><code>customer_name: str | None\n</code></pre> <p>Return the invoicee name, or <code>None</code> if no invoicee is set.</p>"},{"location":"api-reference/models/#teamleader.models.invoice.Invoice.from_api","title":"from_api  <code>classmethod</code>","text":"<pre><code>from_api(data: dict[str, Any]) -&gt; Self\n</code></pre> <p>Deserialise from an <code>invoices.info</code> or <code>invoices.list</code> payload.</p> <p>Accepts both the full response wrapper <code>{\"data\": {...}}</code> and a bare data dict.</p> Source code in <code>teamleader/models/invoice.py</code> <pre><code>@classmethod\ndef from_api(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"Deserialise from an ``invoices.info`` or ``invoices.list`` payload.\n\n    Accepts both the full response wrapper ``{\"data\": {...}}`` and a bare\n    data dict.\n    \"\"\"\n    d = data.get(\"data\", data)\n\n    dept_raw = d.get(\"department\")\n    department = TypeAndId.from_api(dept_raw) if dept_raw else None\n\n    pt_raw = d.get(\"payment_term\")\n    payment_term = PaymentTerm.from_api(pt_raw) if pt_raw else None\n\n    deal_raw = d.get(\"deal\")\n    deal = TypeAndId.from_api(deal_raw) if deal_raw else None\n\n    return cls(\n        id=d.get(\"id\", \"\"),\n        department=department,\n        invoice_number=d.get(\"invoice_number\"),\n        invoice_date=d.get(\"invoice_date\"),\n        status=d.get(\"status\", \"draft\"),\n        due_on=d.get(\"due_on\"),\n        paid=bool(d.get(\"paid\", False)),\n        paid_at=d.get(\"paid_at\"),\n        sent=bool(d.get(\"sent\", False)),\n        purchase_order_number=d.get(\"purchase_order_number\"),\n        invoicee=d.get(\"invoicee\"),\n        discounts=d.get(\"discounts\", []),\n        grouped_lines=d.get(\"grouped_lines\", []),\n        total=d.get(\"total\"),\n        payment_term=payment_term,\n        payments=d.get(\"payments\", []),\n        payment_reference=d.get(\"payment_reference\"),\n        note=d.get(\"note\"),\n        currency=d.get(\"currency\"),\n        currency_exchange_rate=d.get(\"currency_exchange_rate\"),\n        deal=deal,\n        custom_fields=[CustomField.from_api(cf) for cf in d.get(\"custom_fields\", [])],\n        created_at=d.get(\"created_at\"),\n        updated_at=d.get(\"updated_at\"),\n        delivery_date=d.get(\"delivery_date\"),\n    )\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.invoice.Invoice.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Serialise to the shape expected by invoice write endpoints.</p> Source code in <code>teamleader/models/invoice.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialise to the shape expected by invoice write endpoints.\"\"\"\n    out: dict[str, Any] = {\n        \"id\": self.id,\n        \"status\": self.status,\n        \"paid\": self.paid,\n        \"sent\": self.sent,\n        \"custom_fields\": [cf.to_dict() for cf in self.custom_fields],\n    }\n    if self.department is not None:\n        out[\"department\"] = self.department.to_dict()\n    if self.invoice_number is not None:\n        out[\"invoice_number\"] = self.invoice_number\n    if self.invoice_date is not None:\n        out[\"invoice_date\"] = self.invoice_date\n    if self.due_on is not None:\n        out[\"due_on\"] = self.due_on\n    if self.purchase_order_number is not None:\n        out[\"purchase_order_number\"] = self.purchase_order_number\n    if self.invoicee is not None:\n        out[\"invoicee\"] = self.invoicee\n    if self.discounts:\n        out[\"discounts\"] = self.discounts\n    if self.grouped_lines:\n        out[\"grouped_lines\"] = self.grouped_lines\n    if self.payment_term is not None:\n        out[\"payment_term\"] = self.payment_term.to_dict()\n    if self.payment_reference is not None:\n        out[\"payment_reference\"] = self.payment_reference\n    if self.note is not None:\n        out[\"note\"] = self.note\n    if self.currency is not None:\n        out[\"currency\"] = self.currency\n    if self.deal is not None:\n        out[\"deal\"] = self.deal.to_dict()\n    if self.delivery_date is not None:\n        out[\"delivery_date\"] = self.delivery_date\n    return out\n</code></pre>"},{"location":"api-reference/models/#quotation","title":"Quotation","text":""},{"location":"api-reference/models/#teamleader.models.quotation.Quotation","title":"Quotation  <code>dataclass</code>","text":"<p>Represents a Teamleader Focus quotation.</p> <p>All datetime fields are ISO 8601 strings as returned by the API. Use the computed properties for convenient access to common values.</p> Source code in <code>teamleader/models/quotation.py</code> <pre><code>@dataclass\nclass Quotation:\n    \"\"\"Represents a Teamleader Focus quotation.\n\n    All datetime fields are ISO 8601 strings as returned by the API.\n    Use the computed properties for convenient access to common values.\n    \"\"\"\n\n    id: str = \"\"\n    deal: TypeAndId | None = None\n    grouped_lines: list[dict[str, Any]] = field(default_factory=list)\n    currency: str | None = None                 # ISO 4217\n    currency_exchange_rate: dict[str, Any] | None = None\n    text: str | None = None                     # Markdown\n    total: dict[str, Any] | None = None         # tax_exclusive, tax_inclusive, taxes, \u2026\n    discounts: list[dict[str, Any]] = field(default_factory=list)   # CommercialDiscount list\n    status: str = \"open\"                        # \"open\" | \"accepted\" | \"expired\" | \"rejected\" | \"closed\"\n    name: str | None = None\n    document_template: TypeAndId | None = None\n    custom_fields: list[CustomField] = field(default_factory=list)\n    created_at: str | None = None               # ISO 8601 datetime\n    updated_at: str | None = None               # ISO 8601 datetime\n\n    # ------------------------------------------------------------------\n    # Computed properties\n    # ------------------------------------------------------------------\n\n    @property\n    def is_open(self) -&gt; bool:\n        \"\"\"Return ``True`` when the quotation is still awaiting a response.\"\"\"\n        return self.status == \"open\"\n\n    @property\n    def is_accepted(self) -&gt; bool:\n        \"\"\"Return ``True`` when the quotation has been accepted.\"\"\"\n        return self.status == \"accepted\"\n\n    @property\n    def is_expired(self) -&gt; bool:\n        \"\"\"Return ``True`` when the quotation has expired.\"\"\"\n        return self.status == \"expired\"\n\n    @property\n    def total_tax_exclusive(self) -&gt; Money | None:\n        \"\"\"Return the tax-exclusive total amount, or ``None`` if totals not present.\"\"\"\n        if self.total and isinstance(self.total.get(\"tax_exclusive\"), dict):\n            return Money.from_api(self.total[\"tax_exclusive\"])\n        return None\n\n    @property\n    def total_tax_inclusive(self) -&gt; Money | None:\n        \"\"\"Return the tax-inclusive total amount, or ``None`` if totals not present.\"\"\"\n        if self.total and isinstance(self.total.get(\"tax_inclusive\"), dict):\n            return Money.from_api(self.total[\"tax_inclusive\"])\n        return None\n\n    # ------------------------------------------------------------------\n    # Serialisation\n    # ------------------------------------------------------------------\n\n    @classmethod\n    def from_api(cls, data: dict[str, Any]) -&gt; Self:\n        \"\"\"Deserialise from a ``quotations.info`` or ``quotations.list`` payload.\n\n        Accepts both the full response wrapper ``{\"data\": {...}}`` and a bare\n        data dict.\n        \"\"\"\n        d = data.get(\"data\", data)\n\n        deal_raw = d.get(\"deal\")\n        deal = TypeAndId.from_api(deal_raw) if deal_raw else None\n\n        dt_raw = d.get(\"document_template\")\n        document_template = TypeAndId.from_api(dt_raw) if dt_raw else None\n\n        return cls(\n            id=d.get(\"id\", \"\"),\n            deal=deal,\n            grouped_lines=d.get(\"grouped_lines\", []),\n            currency=d.get(\"currency\"),\n            currency_exchange_rate=d.get(\"currency_exchange_rate\"),\n            text=d.get(\"text\"),\n            total=d.get(\"total\"),\n            discounts=d.get(\"discounts\", []),\n            status=d.get(\"status\", \"open\"),\n            name=d.get(\"name\"),\n            document_template=document_template,\n            custom_fields=[CustomField.from_api(cf) for cf in d.get(\"custom_fields\", [])],\n            created_at=d.get(\"created_at\"),\n            updated_at=d.get(\"updated_at\"),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialise to the shape expected by quotation write endpoints.\"\"\"\n        out: dict[str, Any] = {\n            \"id\": self.id,\n            \"status\": self.status,\n            \"custom_fields\": [cf.to_dict() for cf in self.custom_fields],\n        }\n        if self.deal is not None:\n            out[\"deal\"] = self.deal.to_dict()\n        if self.grouped_lines:\n            out[\"grouped_lines\"] = self.grouped_lines\n        if self.currency is not None:\n            out[\"currency\"] = self.currency\n        if self.text is not None:\n            out[\"text\"] = self.text\n        if self.discounts:\n            out[\"discounts\"] = self.discounts\n        if self.name is not None:\n            out[\"name\"] = self.name\n        if self.document_template is not None:\n            out[\"document_template\"] = self.document_template.to_dict()\n        return out\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.quotation.Quotation.is_open","title":"is_open  <code>property</code>","text":"<pre><code>is_open: bool\n</code></pre> <p>Return <code>True</code> when the quotation is still awaiting a response.</p>"},{"location":"api-reference/models/#teamleader.models.quotation.Quotation.is_accepted","title":"is_accepted  <code>property</code>","text":"<pre><code>is_accepted: bool\n</code></pre> <p>Return <code>True</code> when the quotation has been accepted.</p>"},{"location":"api-reference/models/#teamleader.models.quotation.Quotation.is_expired","title":"is_expired  <code>property</code>","text":"<pre><code>is_expired: bool\n</code></pre> <p>Return <code>True</code> when the quotation has expired.</p>"},{"location":"api-reference/models/#teamleader.models.quotation.Quotation.total_tax_exclusive","title":"total_tax_exclusive  <code>property</code>","text":"<pre><code>total_tax_exclusive: Money | None\n</code></pre> <p>Return the tax-exclusive total amount, or <code>None</code> if totals not present.</p>"},{"location":"api-reference/models/#teamleader.models.quotation.Quotation.total_tax_inclusive","title":"total_tax_inclusive  <code>property</code>","text":"<pre><code>total_tax_inclusive: Money | None\n</code></pre> <p>Return the tax-inclusive total amount, or <code>None</code> if totals not present.</p>"},{"location":"api-reference/models/#teamleader.models.quotation.Quotation.from_api","title":"from_api  <code>classmethod</code>","text":"<pre><code>from_api(data: dict[str, Any]) -&gt; Self\n</code></pre> <p>Deserialise from a <code>quotations.info</code> or <code>quotations.list</code> payload.</p> <p>Accepts both the full response wrapper <code>{\"data\": {...}}</code> and a bare data dict.</p> Source code in <code>teamleader/models/quotation.py</code> <pre><code>@classmethod\ndef from_api(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"Deserialise from a ``quotations.info`` or ``quotations.list`` payload.\n\n    Accepts both the full response wrapper ``{\"data\": {...}}`` and a bare\n    data dict.\n    \"\"\"\n    d = data.get(\"data\", data)\n\n    deal_raw = d.get(\"deal\")\n    deal = TypeAndId.from_api(deal_raw) if deal_raw else None\n\n    dt_raw = d.get(\"document_template\")\n    document_template = TypeAndId.from_api(dt_raw) if dt_raw else None\n\n    return cls(\n        id=d.get(\"id\", \"\"),\n        deal=deal,\n        grouped_lines=d.get(\"grouped_lines\", []),\n        currency=d.get(\"currency\"),\n        currency_exchange_rate=d.get(\"currency_exchange_rate\"),\n        text=d.get(\"text\"),\n        total=d.get(\"total\"),\n        discounts=d.get(\"discounts\", []),\n        status=d.get(\"status\", \"open\"),\n        name=d.get(\"name\"),\n        document_template=document_template,\n        custom_fields=[CustomField.from_api(cf) for cf in d.get(\"custom_fields\", [])],\n        created_at=d.get(\"created_at\"),\n        updated_at=d.get(\"updated_at\"),\n    )\n</code></pre>"},{"location":"api-reference/models/#teamleader.models.quotation.Quotation.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Serialise to the shape expected by quotation write endpoints.</p> Source code in <code>teamleader/models/quotation.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialise to the shape expected by quotation write endpoints.\"\"\"\n    out: dict[str, Any] = {\n        \"id\": self.id,\n        \"status\": self.status,\n        \"custom_fields\": [cf.to_dict() for cf in self.custom_fields],\n    }\n    if self.deal is not None:\n        out[\"deal\"] = self.deal.to_dict()\n    if self.grouped_lines:\n        out[\"grouped_lines\"] = self.grouped_lines\n    if self.currency is not None:\n        out[\"currency\"] = self.currency\n    if self.text is not None:\n        out[\"text\"] = self.text\n    if self.discounts:\n        out[\"discounts\"] = self.discounts\n    if self.name is not None:\n        out[\"name\"] = self.name\n    if self.document_template is not None:\n        out[\"document_template\"] = self.document_template.to_dict()\n    return out\n</code></pre>"},{"location":"api-reference/models/#computed-properties-cheat-sheet","title":"Computed properties cheat-sheet","text":""},{"location":"api-reference/models/#contact_1","title":"Contact","text":"Property Returns <code>full_name</code> <code>\"First Last\"</code>, whitespace-stripped <code>primary_email</code> First <code>type=\"primary\"</code> email address, else first email, else <code>None</code> <code>primary_phone</code> First telephone number, or <code>None</code> <code>is_active</code> <code>True</code> when <code>status == \"active\"</code>"},{"location":"api-reference/models/#company_1","title":"Company","text":"Property Returns <code>is_active</code> <code>True</code> when <code>status == \"active\"</code> <code>primary_email</code> Same selection logic as Contact <code>primary_phone</code> First telephone number, or <code>None</code>"},{"location":"api-reference/models/#deal_1","title":"Deal","text":"Property Returns <code>is_open</code> <code>status == \"open\"</code> <code>is_won</code> <code>status == \"won\"</code> <code>is_lost</code> <code>status == \"lost\"</code> <code>customer_id</code> UUID of the lead's customer <code>customer_type</code> <code>\"contact\"</code> or <code>\"company\"</code> <p>Deal.status is an open string</p> <p>The Teamleader API may return undocumented status values (e.g. <code>\"new\"</code>) not in the spec.  <code>Deal.status</code> is therefore <code>str</code>, not an enum.  The boolean properties guard against forward-compatible reads.</p>"},{"location":"api-reference/models/#invoice_1","title":"Invoice","text":"Property Returns <code>is_paid</code> <code>paid == True</code> <code>is_draft</code> <code>status == \"draft\"</code> <code>is_overdue</code> <code>due_on &lt; today AND NOT paid</code> (date-safe, returns <code>False</code> when <code>due_on</code> is <code>None</code>) <code>total_due</code> <code>Money</code> extracted from <code>total[\"due\"]</code>, or <code>None</code> <code>customer_name</code> <code>invoicee[\"name\"]</code>, or <code>None</code>"},{"location":"api-reference/models/#quotation_1","title":"Quotation","text":"Property Returns <code>is_open</code> <code>status == \"open\"</code> <code>is_accepted</code> <code>status == \"accepted\"</code> <code>is_expired</code> <code>status == \"expired\"</code> <code>total_tax_exclusive</code> <code>Money</code> from <code>totals[\"tax_exclusive\"]</code>, or <code>None</code> <code>total_tax_inclusive</code> <code>Money</code> from <code>totals[\"tax_inclusive\"]</code>, or <code>None</code>"},{"location":"api-reference/resources/","title":"Resources \u2014 API Reference","text":"<p>Resource classes expose CRUD operations and resource-specific actions on top of <code>TeamleaderClient</code>.  See the Working with Resources guide for usage examples.</p>"},{"location":"api-reference/resources/#base-classes","title":"Base classes","text":""},{"location":"api-reference/resources/#page","title":"Page","text":"<p><code>Page[M]</code> is returned by every <code>CrudResource.list()</code> call.</p>"},{"location":"api-reference/resources/#teamleader.resources.base.Page","title":"Page  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[M]</code></p> <p>A single page of results from a list endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[M]</code> <p>The deserialised model objects on this page.</p> required <code>total_count</code> <code>int</code> <p>Total number of matching objects across all pages (<code>meta.matches</code> from the API response).</p> required <code>current_page</code> <code>int</code> <p>1-based index of this page.</p> required <code>page_size</code> <code>int</code> <p>Number of items requested per page.</p> required Notes <p>After construction :class:<code>CrudResource</code> injects two private attributes used for forward-pagination.  <code>_resource</code> is a back-reference to the :class:<code>CrudResource</code> that produced this page; <code>_filters</code> are the extra <code>**filters</code> kwargs forwarded verbatim when fetching the next page.</p> Source code in <code>teamleader/resources/base.py</code> <pre><code>@dataclass\nclass Page(Generic[M]):\n    \"\"\"A single page of results from a list endpoint.\n\n    Parameters\n    ----------\n    data:\n        The deserialised model objects on this page.\n    total_count:\n        Total number of matching objects across **all** pages\n        (``meta.matches`` from the API response).\n    current_page:\n        1-based index of this page.\n    page_size:\n        Number of items requested per page.\n\n    Notes\n    -----\n    After construction :class:`CrudResource` injects two private attributes used\n    for forward-pagination.  ``_resource`` is a back-reference to the\n    :class:`CrudResource` that produced this page; ``_filters`` are the extra\n    ``**filters`` kwargs forwarded verbatim when fetching the next page.\n    \"\"\"\n\n    data: list[M]\n    total_count: int\n    current_page: int\n    page_size: int\n\n    # Set by CrudResource after construction \u2014 not part of the public constructor.\n    _resource: Any = field(default=None, init=False, repr=False, compare=False)\n    _filters: dict[str, Any] = field(\n        default_factory=dict, init=False, repr=False, compare=False\n    )\n\n    @property\n    def has_next(self) -&gt; bool:\n        \"\"\"``True`` when at least one more page exists after this one.\n\n        Calculated as ``current_page * page_size &lt; total_count``.  This is\n        correct even when the last page is partially filled (e.g. 5 items with\n        page_size=20 \u2192 ``1 * 20 &lt; 5`` is ``False``).\n        \"\"\"\n        return self.current_page * self.page_size &lt; self.total_count\n\n    def next(self) -&gt; Page[M]:\n        \"\"\"Fetch and return the next page of results.\n\n        Raises\n        ------\n        ValueError\n            If :attr:`has_next` is ``False`` (caller should check before calling).\n        \"\"\"\n        if not self.has_next:\n            raise ValueError(\n                f\"No more pages: page {self.current_page} * size {self.page_size}\"\n                f\" &gt;= total {self.total_count}\"\n            )\n        return self._resource.list(\n            page=self.current_page + 1,\n            page_size=self.page_size,\n            **self._filters,\n        )\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.base.Page.has_next","title":"has_next  <code>property</code>","text":"<pre><code>has_next: bool\n</code></pre> <p><code>True</code> when at least one more page exists after this one.</p> <p>Calculated as <code>current_page * page_size &lt; total_count</code>.  This is correct even when the last page is partially filled (e.g. 5 items with page_size=20 \u2192 <code>1 * 20 &lt; 5</code> is <code>False</code>).</p>"},{"location":"api-reference/resources/#teamleader.resources.base.Page.next","title":"next","text":"<pre><code>next() -&gt; Page[M]\n</code></pre> <p>Fetch and return the next page of results.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If :attr:<code>has_next</code> is <code>False</code> (caller should check before calling).</p> Source code in <code>teamleader/resources/base.py</code> <pre><code>def next(self) -&gt; Page[M]:\n    \"\"\"Fetch and return the next page of results.\n\n    Raises\n    ------\n    ValueError\n        If :attr:`has_next` is ``False`` (caller should check before calling).\n    \"\"\"\n    if not self.has_next:\n        raise ValueError(\n            f\"No more pages: page {self.current_page} * size {self.page_size}\"\n            f\" &gt;= total {self.total_count}\"\n        )\n    return self._resource.list(\n        page=self.current_page + 1,\n        page_size=self.page_size,\n        **self._filters,\n    )\n</code></pre>"},{"location":"api-reference/resources/#crudresource","title":"CrudResource","text":"<p><code>CrudResource[M]</code> is the base class for all five curated resources.</p>"},{"location":"api-reference/resources/#teamleader.resources.base.CrudResource","title":"CrudResource","text":"<p>               Bases: <code>Generic[M]</code></p> <p>Generic CRUD resource base class.</p> <p>Subclasses must set two class-level attributes:</p> <p><code>prefix</code>     The Teamleader API resource prefix, e.g. <code>\"contacts\"</code>.  Combined with     an operation name to build the endpoint path: <code>contacts.list</code>,     <code>contacts.info</code>, etc.</p> <p><code>model</code>     The model class to deserialise API payloads into.  Must implement a     <code>from_api(dict) -&gt; M</code> classmethod.</p> <p>All Teamleader API calls use POST; both :meth:<code>list</code> and mutating operations go through :meth:<code>~teamleader.client.TeamleaderClient._post</code>.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TeamleaderClient</code> <p>A fully configured :class:<code>~teamleader.client.TeamleaderClient</code>.</p> required Source code in <code>teamleader/resources/base.py</code> <pre><code>class CrudResource(Generic[M]):\n    \"\"\"Generic CRUD resource base class.\n\n    Subclasses **must** set two class-level attributes:\n\n    ``prefix``\n        The Teamleader API resource prefix, e.g. ``\"contacts\"``.  Combined with\n        an operation name to build the endpoint path: ``contacts.list``,\n        ``contacts.info``, etc.\n\n    ``model``\n        The model class to deserialise API payloads into.  Must implement a\n        ``from_api(dict) -&gt; M`` classmethod.\n\n    All Teamleader API calls use POST; both :meth:`list` and mutating operations\n    go through :meth:`~teamleader.client.TeamleaderClient._post`.\n\n    Parameters\n    ----------\n    client:\n        A fully configured :class:`~teamleader.client.TeamleaderClient`.\n    \"\"\"\n\n    prefix: str = \"\"\n    model: type[M]  # type: ignore[misc]\n\n    def __init__(self, client: TeamleaderClient) -&gt; None:\n        self._client = client\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n\n    def _path(self, operation: str) -&gt; str:\n        \"\"\"Build the full operation path, e.g. ``contacts.list``.\n\n        Parameters\n        ----------\n        operation:\n            The operation suffix \u2014 ``\"list\"``, ``\"info\"``, ``\"add\"``,\n            ``\"update\"``, ``\"delete\"``, or any resource-specific action.\n        \"\"\"\n        return f\"{self.prefix}.{operation}\"\n\n    def _deserialise(self, data: dict[str, Any]) -&gt; M:\n        \"\"\"Deserialise a single API object dict into a model instance.\n\n        Delegates to ``model.from_api(data)``.\n        \"\"\"\n        return self.model.from_api(data)  # type: ignore[return-value]\n\n    # ------------------------------------------------------------------\n    # CRUD operations\n    # ------------------------------------------------------------------\n\n    def list(\n        self,\n        *,\n        page: int = 1,\n        page_size: int = DEFAULT_PAGE_SIZE,\n        **filters: Any,\n    ) -&gt; Page[M]:\n        \"\"\"Return a single page of results.\n\n        Parameters\n        ----------\n        page:\n            1-based page number.  Defaults to ``1``.\n        page_size:\n            Number of items per page.  Defaults to\n            :data:`~teamleader.constants.DEFAULT_PAGE_SIZE` (20).\n        **filters:\n            Extra top-level body parameters forwarded to the API, e.g.\n            ``filter={\"email\": \"...\"}``, ``sort=[...]``, ``includes=[...]``.\n            These are stored on the returned :class:`Page` so that\n            :meth:`Page.next` can continue with the same filters.\n\n        Returns\n        -------\n        Page[M]\n            A page whose ``total_count`` reflects ``meta.matches`` from the\n            API response \u2014 the total across **all** pages, not just this one.\n        \"\"\"\n        body: dict[str, Any] = {\n            \"page\": {\"size\": page_size, \"number\": page},\n            **filters,\n        }\n\n        # Always request the pagination include so the API returns meta.matches\n        # for endpoints that support it (companies, deals, invoices, \u2026).\n        # Merge with any caller-supplied includes without mutating the original\n        # ``filters`` dict \u2014 that dict is stored verbatim on ``page._filters``\n        # so that ``Page.next()`` replays the user-visible includes on every page.\n        user_includes = body.get(\"includes\", \"\") or \"\"\n        body[\"includes\"] = \",\".join(filter(None, [user_includes, \"pagination\"]))\n\n        resp = self._client._post(self._path(\"list\"), body)\n        items = [self._deserialise(d) for d in resp[\"data\"]]\n\n        # meta.matches is returned only when the endpoint supports\n        # ``includes=pagination`` (contacts.list does not; companies and deals do).\n        # Fall back to a length-based heuristic when it is absent:\n        #   \u2022 fewer items than page_size  \u2192 definitely last page\n        #   \u2022 exactly page_size items     \u2192 assume at least one more page exists\n        # The heuristic causes one extra empty request at the end of iteration,\n        # which ``iterate()`` handles gracefully.\n        meta: dict[str, Any] = resp.get(\"meta\") or {}\n        if \"matches\" in meta:\n            total_count = int(meta[\"matches\"])\n        elif len(items) &lt; page_size:\n            # Partial page \u2014 we know the exact total\n            total_count = (page - 1) * page_size + len(items)\n        else:\n            # Full page \u2014 signal \"might have more\" with one item over the threshold\n            total_count = page * page_size + 1\n\n        page_obj = Page(\n            data=items,\n            total_count=total_count,\n            current_page=page,\n            page_size=page_size,\n        )\n        page_obj._resource = self\n        page_obj._filters = filters\n        return page_obj\n\n    def get(self, id: str) -&gt; M:\n        \"\"\"Fetch a single object by ID.\n\n        Uses the ``{prefix}.info`` endpoint (Teamleader's canonical name for\n        single-object retrieval \u2014 not ``.get``).\n\n        Parameters\n        ----------\n        id:\n            The UUID of the object to retrieve.\n        \"\"\"\n        resp = self._client._post(self._path(\"info\"), {\"id\": id})\n        return self._deserialise(resp[\"data\"])\n\n    def create(self, **kwargs: Any) -&gt; M:\n        \"\"\"Create a new object and return the fully-populated model.\n\n        POSTs ``kwargs`` to the ``{prefix}.add`` endpoint.  The API returns a\n        minimal reference ``{\"data\": {\"type\": \"...\", \"id\": \"...\"}}``; this\n        method re-fetches the full object via :meth:`get` before returning.\n\n        Parameters\n        ----------\n        **kwargs:\n            Fields to set on the new object, as accepted by the ``add``\n            endpoint for this resource.\n        \"\"\"\n        resp = self._client._post(self._path(\"add\"), kwargs)\n        new_id: str = resp[\"data\"][\"id\"]\n        return self.get(new_id)\n\n    def update(self, id: str, **kwargs: Any) -&gt; M:\n        \"\"\"Update an existing object and return the refreshed model.\n\n        POSTs ``{\"id\": id, **kwargs}`` to the ``{prefix}.update`` endpoint.\n        The API returns an empty body on success; this method re-fetches the\n        updated object via :meth:`get` before returning.\n\n        Parameters\n        ----------\n        id:\n            The UUID of the object to update.\n        **kwargs:\n            Fields to change, as accepted by the ``update`` endpoint.\n        \"\"\"\n        self._client._post(self._path(\"update\"), {\"id\": id, **kwargs})\n        return self.get(id)\n\n    def delete(self, id: str) -&gt; None:\n        \"\"\"Delete an object by ID.\n\n        POSTs ``{\"id\": id}`` to the ``{prefix}.delete`` endpoint.  Returns\n        ``None`` on success; raises a\n        :class:`~teamleader.exceptions.TeamleaderError` subclass on failure.\n\n        Parameters\n        ----------\n        id:\n            The UUID of the object to delete.\n        \"\"\"\n        self._client._post(self._path(\"delete\"), {\"id\": id})\n\n    def iterate(self, page_size: int = DEFAULT_PAGE_SIZE, **filters: Any) -&gt; Iterator[M]:\n        \"\"\"Yield every matching object, transparently fetching additional pages.\n\n        This is the preferred way to consume a full result set without dealing\n        with pagination manually::\n\n            for contact in client.contacts.iterate():\n                print(contact.full_name)\n\n        Parameters\n        ----------\n        page_size:\n            Items per page for each underlying :meth:`list` call.  Defaults to\n            :data:`~teamleader.constants.DEFAULT_PAGE_SIZE` (20).\n        **filters:\n            Forwarded to every :meth:`list` call (same semantics as\n            :meth:`list`'s ``**filters``).\n        \"\"\"\n        current = self.list(page=1, page_size=page_size, **filters)\n        while True:\n            yield from current.data\n            if not current.has_next:\n                break\n            current = current.next()\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.base.CrudResource.list","title":"list","text":"<pre><code>list(\n    *,\n    page: int = 1,\n    page_size: int = DEFAULT_PAGE_SIZE,\n    **filters: Any\n) -&gt; Page[M]\n</code></pre> <p>Return a single page of results.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>1-based page number.  Defaults to <code>1</code>.</p> <code>1</code> <code>page_size</code> <code>int</code> <p>Number of items per page.  Defaults to :data:<code>~teamleader.constants.DEFAULT_PAGE_SIZE</code> (20).</p> <code>DEFAULT_PAGE_SIZE</code> <code>**filters</code> <code>Any</code> <p>Extra top-level body parameters forwarded to the API, e.g. <code>filter={\"email\": \"...\"}</code>, <code>sort=[...]</code>, <code>includes=[...]</code>. These are stored on the returned :class:<code>Page</code> so that :meth:<code>Page.next</code> can continue with the same filters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Page[M]</code> <p>A page whose <code>total_count</code> reflects <code>meta.matches</code> from the API response \u2014 the total across all pages, not just this one.</p> Source code in <code>teamleader/resources/base.py</code> <pre><code>def list(\n    self,\n    *,\n    page: int = 1,\n    page_size: int = DEFAULT_PAGE_SIZE,\n    **filters: Any,\n) -&gt; Page[M]:\n    \"\"\"Return a single page of results.\n\n    Parameters\n    ----------\n    page:\n        1-based page number.  Defaults to ``1``.\n    page_size:\n        Number of items per page.  Defaults to\n        :data:`~teamleader.constants.DEFAULT_PAGE_SIZE` (20).\n    **filters:\n        Extra top-level body parameters forwarded to the API, e.g.\n        ``filter={\"email\": \"...\"}``, ``sort=[...]``, ``includes=[...]``.\n        These are stored on the returned :class:`Page` so that\n        :meth:`Page.next` can continue with the same filters.\n\n    Returns\n    -------\n    Page[M]\n        A page whose ``total_count`` reflects ``meta.matches`` from the\n        API response \u2014 the total across **all** pages, not just this one.\n    \"\"\"\n    body: dict[str, Any] = {\n        \"page\": {\"size\": page_size, \"number\": page},\n        **filters,\n    }\n\n    # Always request the pagination include so the API returns meta.matches\n    # for endpoints that support it (companies, deals, invoices, \u2026).\n    # Merge with any caller-supplied includes without mutating the original\n    # ``filters`` dict \u2014 that dict is stored verbatim on ``page._filters``\n    # so that ``Page.next()`` replays the user-visible includes on every page.\n    user_includes = body.get(\"includes\", \"\") or \"\"\n    body[\"includes\"] = \",\".join(filter(None, [user_includes, \"pagination\"]))\n\n    resp = self._client._post(self._path(\"list\"), body)\n    items = [self._deserialise(d) for d in resp[\"data\"]]\n\n    # meta.matches is returned only when the endpoint supports\n    # ``includes=pagination`` (contacts.list does not; companies and deals do).\n    # Fall back to a length-based heuristic when it is absent:\n    #   \u2022 fewer items than page_size  \u2192 definitely last page\n    #   \u2022 exactly page_size items     \u2192 assume at least one more page exists\n    # The heuristic causes one extra empty request at the end of iteration,\n    # which ``iterate()`` handles gracefully.\n    meta: dict[str, Any] = resp.get(\"meta\") or {}\n    if \"matches\" in meta:\n        total_count = int(meta[\"matches\"])\n    elif len(items) &lt; page_size:\n        # Partial page \u2014 we know the exact total\n        total_count = (page - 1) * page_size + len(items)\n    else:\n        # Full page \u2014 signal \"might have more\" with one item over the threshold\n        total_count = page * page_size + 1\n\n    page_obj = Page(\n        data=items,\n        total_count=total_count,\n        current_page=page,\n        page_size=page_size,\n    )\n    page_obj._resource = self\n    page_obj._filters = filters\n    return page_obj\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.base.CrudResource.get","title":"get","text":"<pre><code>get(id: str) -&gt; M\n</code></pre> <p>Fetch a single object by ID.</p> <p>Uses the <code>{prefix}.info</code> endpoint (Teamleader's canonical name for single-object retrieval \u2014 not <code>.get</code>).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The UUID of the object to retrieve.</p> required Source code in <code>teamleader/resources/base.py</code> <pre><code>def get(self, id: str) -&gt; M:\n    \"\"\"Fetch a single object by ID.\n\n    Uses the ``{prefix}.info`` endpoint (Teamleader's canonical name for\n    single-object retrieval \u2014 not ``.get``).\n\n    Parameters\n    ----------\n    id:\n        The UUID of the object to retrieve.\n    \"\"\"\n    resp = self._client._post(self._path(\"info\"), {\"id\": id})\n    return self._deserialise(resp[\"data\"])\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.base.CrudResource.create","title":"create","text":"<pre><code>create(**kwargs: Any) -&gt; M\n</code></pre> <p>Create a new object and return the fully-populated model.</p> <p>POSTs <code>kwargs</code> to the <code>{prefix}.add</code> endpoint.  The API returns a minimal reference <code>{\"data\": {\"type\": \"...\", \"id\": \"...\"}}</code>; this method re-fetches the full object via :meth:<code>get</code> before returning.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Fields to set on the new object, as accepted by the <code>add</code> endpoint for this resource.</p> <code>{}</code> Source code in <code>teamleader/resources/base.py</code> <pre><code>def create(self, **kwargs: Any) -&gt; M:\n    \"\"\"Create a new object and return the fully-populated model.\n\n    POSTs ``kwargs`` to the ``{prefix}.add`` endpoint.  The API returns a\n    minimal reference ``{\"data\": {\"type\": \"...\", \"id\": \"...\"}}``; this\n    method re-fetches the full object via :meth:`get` before returning.\n\n    Parameters\n    ----------\n    **kwargs:\n        Fields to set on the new object, as accepted by the ``add``\n        endpoint for this resource.\n    \"\"\"\n    resp = self._client._post(self._path(\"add\"), kwargs)\n    new_id: str = resp[\"data\"][\"id\"]\n    return self.get(new_id)\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.base.CrudResource.update","title":"update","text":"<pre><code>update(id: str, **kwargs: Any) -&gt; M\n</code></pre> <p>Update an existing object and return the refreshed model.</p> <p>POSTs <code>{\"id\": id, **kwargs}</code> to the <code>{prefix}.update</code> endpoint. The API returns an empty body on success; this method re-fetches the updated object via :meth:<code>get</code> before returning.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The UUID of the object to update.</p> required <code>**kwargs</code> <code>Any</code> <p>Fields to change, as accepted by the <code>update</code> endpoint.</p> <code>{}</code> Source code in <code>teamleader/resources/base.py</code> <pre><code>def update(self, id: str, **kwargs: Any) -&gt; M:\n    \"\"\"Update an existing object and return the refreshed model.\n\n    POSTs ``{\"id\": id, **kwargs}`` to the ``{prefix}.update`` endpoint.\n    The API returns an empty body on success; this method re-fetches the\n    updated object via :meth:`get` before returning.\n\n    Parameters\n    ----------\n    id:\n        The UUID of the object to update.\n    **kwargs:\n        Fields to change, as accepted by the ``update`` endpoint.\n    \"\"\"\n    self._client._post(self._path(\"update\"), {\"id\": id, **kwargs})\n    return self.get(id)\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.base.CrudResource.delete","title":"delete","text":"<pre><code>delete(id: str) -&gt; None\n</code></pre> <p>Delete an object by ID.</p> <p>POSTs <code>{\"id\": id}</code> to the <code>{prefix}.delete</code> endpoint.  Returns <code>None</code> on success; raises a :class:<code>~teamleader.exceptions.TeamleaderError</code> subclass on failure.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The UUID of the object to delete.</p> required Source code in <code>teamleader/resources/base.py</code> <pre><code>def delete(self, id: str) -&gt; None:\n    \"\"\"Delete an object by ID.\n\n    POSTs ``{\"id\": id}`` to the ``{prefix}.delete`` endpoint.  Returns\n    ``None`` on success; raises a\n    :class:`~teamleader.exceptions.TeamleaderError` subclass on failure.\n\n    Parameters\n    ----------\n    id:\n        The UUID of the object to delete.\n    \"\"\"\n    self._client._post(self._path(\"delete\"), {\"id\": id})\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.base.CrudResource.iterate","title":"iterate","text":"<pre><code>iterate(\n    page_size: int = DEFAULT_PAGE_SIZE, **filters: Any\n) -&gt; Iterator[M]\n</code></pre> <p>Yield every matching object, transparently fetching additional pages.</p> <p>This is the preferred way to consume a full result set without dealing with pagination manually::</p> <pre><code>for contact in client.contacts.iterate():\n    print(contact.full_name)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>page_size</code> <code>int</code> <p>Items per page for each underlying :meth:<code>list</code> call.  Defaults to :data:<code>~teamleader.constants.DEFAULT_PAGE_SIZE</code> (20).</p> <code>DEFAULT_PAGE_SIZE</code> <code>**filters</code> <code>Any</code> <p>Forwarded to every :meth:<code>list</code> call (same semantics as :meth:<code>list</code>'s <code>**filters</code>).</p> <code>{}</code> Source code in <code>teamleader/resources/base.py</code> <pre><code>def iterate(self, page_size: int = DEFAULT_PAGE_SIZE, **filters: Any) -&gt; Iterator[M]:\n    \"\"\"Yield every matching object, transparently fetching additional pages.\n\n    This is the preferred way to consume a full result set without dealing\n    with pagination manually::\n\n        for contact in client.contacts.iterate():\n            print(contact.full_name)\n\n    Parameters\n    ----------\n    page_size:\n        Items per page for each underlying :meth:`list` call.  Defaults to\n        :data:`~teamleader.constants.DEFAULT_PAGE_SIZE` (20).\n    **filters:\n        Forwarded to every :meth:`list` call (same semantics as\n        :meth:`list`'s ``**filters``).\n    \"\"\"\n    current = self.list(page=1, page_size=page_size, **filters)\n    while True:\n        yield from current.data\n        if not current.has_next:\n            break\n        current = current.next()\n</code></pre>"},{"location":"api-reference/resources/#contacts","title":"Contacts","text":""},{"location":"api-reference/resources/#teamleader.resources.contacts.ContactsResource","title":"ContactsResource","text":"<p>               Bases: <code>CrudResource[Contact]</code></p> <p>CRUD + extra actions for Teamleader contacts.</p> <p>Inherits :meth:<code>list</code>, :meth:<code>get</code>, :meth:<code>create</code>, :meth:<code>update</code>, :meth:<code>delete</code>, and :meth:<code>iterate</code> from :class:<code>~teamleader.resources.base.CrudResource</code>.</p> Source code in <code>teamleader/resources/contacts.py</code> <pre><code>class ContactsResource(CrudResource[Contact]):\n    \"\"\"CRUD + extra actions for Teamleader contacts.\n\n    Inherits :meth:`list`, :meth:`get`, :meth:`create`, :meth:`update`,\n    :meth:`delete`, and :meth:`iterate` from :class:`~teamleader.resources.base.CrudResource`.\n    \"\"\"\n\n    prefix = \"contacts\"\n    model = Contact\n\n    # ------------------------------------------------------------------\n    # Tagging\n    # ------------------------------------------------------------------\n\n    def tag(self, contact_id: str, tags: list[str]) -&gt; None:\n        \"\"\"Add one or more tags to a contact.\n\n        Calls ``contacts.tag``.  Tags that already exist on the contact are\n        silently ignored by the API.\n\n        Parameters\n        ----------\n        contact_id:\n            UUID of the contact to tag.\n        tags:\n            List of tag strings (new or existing) to add.\n        \"\"\"\n        self._client._post(\"contacts.tag\", {\"id\": contact_id, \"tags\": tags})\n\n    def untag(self, contact_id: str, tags: list[str]) -&gt; None:\n        \"\"\"Remove one or more tags from a contact.\n\n        Calls ``contacts.untag``.  Tags that are not present are silently\n        ignored by the API.\n\n        Parameters\n        ----------\n        contact_id:\n            UUID of the contact to untag.\n        tags:\n            List of tag strings to remove.\n        \"\"\"\n        self._client._post(\"contacts.untag\", {\"id\": contact_id, \"tags\": tags})\n\n    # ------------------------------------------------------------------\n    # Company linking\n    # ------------------------------------------------------------------\n\n    def link_to_company(\n        self,\n        contact_id: str,\n        company_id: str,\n        *,\n        position: str | None = None,\n        decision_maker: bool | None = None,\n    ) -&gt; None:\n        \"\"\"Link a contact to a company.\n\n        Calls ``contacts.linkToCompany``.\n\n        Parameters\n        ----------\n        contact_id:\n            UUID of the contact.\n        company_id:\n            UUID of the company to link to.\n        position:\n            Optional job title at the company (e.g. ``\"CEO\"``).\n        decision_maker:\n            Optional flag indicating whether this contact is a decision maker\n            at the linked company.\n        \"\"\"\n        body: dict = {\"id\": contact_id, \"company_id\": company_id}\n        if position is not None:\n            body[\"position\"] = position\n        if decision_maker is not None:\n            body[\"decision_maker\"] = decision_maker\n        self._client._post(\"contacts.linkToCompany\", body)\n\n    def unlink_from_company(self, contact_id: str, company_id: str) -&gt; None:\n        \"\"\"Remove the link between a contact and a company.\n\n        Calls ``contacts.unlinkFromCompany``.\n\n        Parameters\n        ----------\n        contact_id:\n            UUID of the contact.\n        company_id:\n            UUID of the company to unlink from.\n        \"\"\"\n        self._client._post(\n            \"contacts.unlinkFromCompany\",\n            {\"id\": contact_id, \"company_id\": company_id},\n        )\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.contacts.ContactsResource.tag","title":"tag","text":"<pre><code>tag(contact_id: str, tags: list[str]) -&gt; None\n</code></pre> <p>Add one or more tags to a contact.</p> <p>Calls <code>contacts.tag</code>.  Tags that already exist on the contact are silently ignored by the API.</p> <p>Parameters:</p> Name Type Description Default <code>contact_id</code> <code>str</code> <p>UUID of the contact to tag.</p> required <code>tags</code> <code>list[str]</code> <p>List of tag strings (new or existing) to add.</p> required Source code in <code>teamleader/resources/contacts.py</code> <pre><code>def tag(self, contact_id: str, tags: list[str]) -&gt; None:\n    \"\"\"Add one or more tags to a contact.\n\n    Calls ``contacts.tag``.  Tags that already exist on the contact are\n    silently ignored by the API.\n\n    Parameters\n    ----------\n    contact_id:\n        UUID of the contact to tag.\n    tags:\n        List of tag strings (new or existing) to add.\n    \"\"\"\n    self._client._post(\"contacts.tag\", {\"id\": contact_id, \"tags\": tags})\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.contacts.ContactsResource.untag","title":"untag","text":"<pre><code>untag(contact_id: str, tags: list[str]) -&gt; None\n</code></pre> <p>Remove one or more tags from a contact.</p> <p>Calls <code>contacts.untag</code>.  Tags that are not present are silently ignored by the API.</p> <p>Parameters:</p> Name Type Description Default <code>contact_id</code> <code>str</code> <p>UUID of the contact to untag.</p> required <code>tags</code> <code>list[str]</code> <p>List of tag strings to remove.</p> required Source code in <code>teamleader/resources/contacts.py</code> <pre><code>def untag(self, contact_id: str, tags: list[str]) -&gt; None:\n    \"\"\"Remove one or more tags from a contact.\n\n    Calls ``contacts.untag``.  Tags that are not present are silently\n    ignored by the API.\n\n    Parameters\n    ----------\n    contact_id:\n        UUID of the contact to untag.\n    tags:\n        List of tag strings to remove.\n    \"\"\"\n    self._client._post(\"contacts.untag\", {\"id\": contact_id, \"tags\": tags})\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.contacts.ContactsResource.link_to_company","title":"link_to_company","text":"<pre><code>link_to_company(\n    contact_id: str,\n    company_id: str,\n    *,\n    position: str | None = None,\n    decision_maker: bool | None = None\n) -&gt; None\n</code></pre> <p>Link a contact to a company.</p> <p>Calls <code>contacts.linkToCompany</code>.</p> <p>Parameters:</p> Name Type Description Default <code>contact_id</code> <code>str</code> <p>UUID of the contact.</p> required <code>company_id</code> <code>str</code> <p>UUID of the company to link to.</p> required <code>position</code> <code>str | None</code> <p>Optional job title at the company (e.g. <code>\"CEO\"</code>).</p> <code>None</code> <code>decision_maker</code> <code>bool | None</code> <p>Optional flag indicating whether this contact is a decision maker at the linked company.</p> <code>None</code> Source code in <code>teamleader/resources/contacts.py</code> <pre><code>def link_to_company(\n    self,\n    contact_id: str,\n    company_id: str,\n    *,\n    position: str | None = None,\n    decision_maker: bool | None = None,\n) -&gt; None:\n    \"\"\"Link a contact to a company.\n\n    Calls ``contacts.linkToCompany``.\n\n    Parameters\n    ----------\n    contact_id:\n        UUID of the contact.\n    company_id:\n        UUID of the company to link to.\n    position:\n        Optional job title at the company (e.g. ``\"CEO\"``).\n    decision_maker:\n        Optional flag indicating whether this contact is a decision maker\n        at the linked company.\n    \"\"\"\n    body: dict = {\"id\": contact_id, \"company_id\": company_id}\n    if position is not None:\n        body[\"position\"] = position\n    if decision_maker is not None:\n        body[\"decision_maker\"] = decision_maker\n    self._client._post(\"contacts.linkToCompany\", body)\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.contacts.ContactsResource.unlink_from_company","title":"unlink_from_company","text":"<pre><code>unlink_from_company(\n    contact_id: str, company_id: str\n) -&gt; None\n</code></pre> <p>Remove the link between a contact and a company.</p> <p>Calls <code>contacts.unlinkFromCompany</code>.</p> <p>Parameters:</p> Name Type Description Default <code>contact_id</code> <code>str</code> <p>UUID of the contact.</p> required <code>company_id</code> <code>str</code> <p>UUID of the company to unlink from.</p> required Source code in <code>teamleader/resources/contacts.py</code> <pre><code>def unlink_from_company(self, contact_id: str, company_id: str) -&gt; None:\n    \"\"\"Remove the link between a contact and a company.\n\n    Calls ``contacts.unlinkFromCompany``.\n\n    Parameters\n    ----------\n    contact_id:\n        UUID of the contact.\n    company_id:\n        UUID of the company to unlink from.\n    \"\"\"\n    self._client._post(\n        \"contacts.unlinkFromCompany\",\n        {\"id\": contact_id, \"company_id\": company_id},\n    )\n</code></pre>"},{"location":"api-reference/resources/#companies","title":"Companies","text":""},{"location":"api-reference/resources/#teamleader.resources.companies.CompaniesResource","title":"CompaniesResource","text":"<p>               Bases: <code>CrudResource[Company]</code></p> <p>CRUD + extra actions for Teamleader companies.</p> <p>Inherits :meth:<code>list</code>, :meth:<code>get</code>, :meth:<code>create</code>, :meth:<code>update</code>, :meth:<code>delete</code>, and :meth:<code>iterate</code> from :class:<code>~teamleader.resources.base.CrudResource</code>.</p> Source code in <code>teamleader/resources/companies.py</code> <pre><code>class CompaniesResource(CrudResource[Company]):\n    \"\"\"CRUD + extra actions for Teamleader companies.\n\n    Inherits :meth:`list`, :meth:`get`, :meth:`create`, :meth:`update`,\n    :meth:`delete`, and :meth:`iterate` from :class:`~teamleader.resources.base.CrudResource`.\n    \"\"\"\n\n    prefix = \"companies\"\n    model = Company\n\n    def tag(self, company_id: str, tags: list[str]) -&gt; None:\n        \"\"\"Add one or more tags to a company.\n\n        Calls ``companies.tag``.  Tags that already exist on the company are\n        silently ignored by the API.\n\n        Parameters\n        ----------\n        company_id:\n            UUID of the company to tag.\n        tags:\n            List of tag strings (new or existing) to add.\n        \"\"\"\n        self._client._post(\"companies.tag\", {\"id\": company_id, \"tags\": tags})\n\n    def untag(self, company_id: str, tags: list[str]) -&gt; None:\n        \"\"\"Remove one or more tags from a company.\n\n        Calls ``companies.untag``.  Tags that are not present are silently\n        ignored by the API.\n\n        Parameters\n        ----------\n        company_id:\n            UUID of the company to untag.\n        tags:\n            List of tag strings to remove.\n        \"\"\"\n        self._client._post(\"companies.untag\", {\"id\": company_id, \"tags\": tags})\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.companies.CompaniesResource.tag","title":"tag","text":"<pre><code>tag(company_id: str, tags: list[str]) -&gt; None\n</code></pre> <p>Add one or more tags to a company.</p> <p>Calls <code>companies.tag</code>.  Tags that already exist on the company are silently ignored by the API.</p> <p>Parameters:</p> Name Type Description Default <code>company_id</code> <code>str</code> <p>UUID of the company to tag.</p> required <code>tags</code> <code>list[str]</code> <p>List of tag strings (new or existing) to add.</p> required Source code in <code>teamleader/resources/companies.py</code> <pre><code>def tag(self, company_id: str, tags: list[str]) -&gt; None:\n    \"\"\"Add one or more tags to a company.\n\n    Calls ``companies.tag``.  Tags that already exist on the company are\n    silently ignored by the API.\n\n    Parameters\n    ----------\n    company_id:\n        UUID of the company to tag.\n    tags:\n        List of tag strings (new or existing) to add.\n    \"\"\"\n    self._client._post(\"companies.tag\", {\"id\": company_id, \"tags\": tags})\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.companies.CompaniesResource.untag","title":"untag","text":"<pre><code>untag(company_id: str, tags: list[str]) -&gt; None\n</code></pre> <p>Remove one or more tags from a company.</p> <p>Calls <code>companies.untag</code>.  Tags that are not present are silently ignored by the API.</p> <p>Parameters:</p> Name Type Description Default <code>company_id</code> <code>str</code> <p>UUID of the company to untag.</p> required <code>tags</code> <code>list[str]</code> <p>List of tag strings to remove.</p> required Source code in <code>teamleader/resources/companies.py</code> <pre><code>def untag(self, company_id: str, tags: list[str]) -&gt; None:\n    \"\"\"Remove one or more tags from a company.\n\n    Calls ``companies.untag``.  Tags that are not present are silently\n    ignored by the API.\n\n    Parameters\n    ----------\n    company_id:\n        UUID of the company to untag.\n    tags:\n        List of tag strings to remove.\n    \"\"\"\n    self._client._post(\"companies.untag\", {\"id\": company_id, \"tags\": tags})\n</code></pre>"},{"location":"api-reference/resources/#deals","title":"Deals","text":""},{"location":"api-reference/resources/#teamleader.resources.deals.DealsResource","title":"DealsResource","text":"<p>               Bases: <code>CrudResource[Deal]</code></p> <p>CRUD + extra actions for Teamleader deals.</p> <p>Inherits :meth:<code>list</code>, :meth:<code>get</code>, :meth:<code>create</code>, :meth:<code>update</code>, :meth:<code>delete</code>, and :meth:<code>iterate</code> from :class:<code>~teamleader.resources.base.CrudResource</code>.</p> Source code in <code>teamleader/resources/deals.py</code> <pre><code>class DealsResource(CrudResource[Deal]):\n    \"\"\"CRUD + extra actions for Teamleader deals.\n\n    Inherits :meth:`list`, :meth:`get`, :meth:`create`, :meth:`update`,\n    :meth:`delete`, and :meth:`iterate` from :class:`~teamleader.resources.base.CrudResource`.\n    \"\"\"\n\n    prefix = \"deals\"\n    model = Deal\n\n    # ------------------------------------------------------------------\n    # Status transitions\n    # ------------------------------------------------------------------\n\n    def move_to_phase(self, deal_id: str, phase_id: str) -&gt; None:\n        \"\"\"Move a deal to a different pipeline phase.\n\n        Calls ``deals.move``.\n\n        Parameters\n        ----------\n        deal_id:\n            UUID of the deal to move.\n        phase_id:\n            UUID of the target deal phase.\n        \"\"\"\n        self._client._post(\"deals.move\", {\"id\": deal_id, \"phase_id\": phase_id})\n\n    def win(self, deal_id: str) -&gt; None:\n        \"\"\"Mark a deal as won.\n\n        Calls ``deals.win``.\n\n        Parameters\n        ----------\n        deal_id:\n            UUID of the deal to mark as won.\n        \"\"\"\n        self._client._post(\"deals.win\", {\"id\": deal_id})\n\n    def lose(\n        self,\n        deal_id: str,\n        *,\n        reason_id: str | None = None,\n        extra_info: str | None = None,\n    ) -&gt; None:\n        \"\"\"Mark a deal as lost.\n\n        Calls ``deals.lose``.\n\n        Parameters\n        ----------\n        deal_id:\n            UUID of the deal to mark as lost.\n        reason_id:\n            Optional UUID of a configured lost-reason.\n        extra_info:\n            Optional free-text explanation (e.g. ``\"Too expensive\"``).\n        \"\"\"\n        body: dict[str, Any] = {\"id\": deal_id}\n        if reason_id is not None:\n            body[\"reason_id\"] = reason_id\n        if extra_info is not None:\n            body[\"extra_info\"] = extra_info\n        self._client._post(\"deals.lose\", body)\n\n    # ------------------------------------------------------------------\n    # Reference data\n    # ------------------------------------------------------------------\n\n    def list_phases(\n        self,\n        *,\n        deal_pipeline_id: str | None = None,\n        ids: list[str] | None = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Return all deal phases from the ``dealPhases.list`` endpoint.\n\n        Parameters\n        ----------\n        deal_pipeline_id:\n            Optional UUID \u2014 filter phases to a specific pipeline.\n        ids:\n            Optional list of phase UUIDs to retrieve.\n\n        Returns\n        -------\n        list[dict]\n            Raw phase dicts as returned by the API (``id``, ``name``,\n            ``actions``, ``expected_duration_in_days``).\n        \"\"\"\n        body: dict[str, Any] = {}\n        filter_: dict[str, Any] = {}\n        if deal_pipeline_id is not None:\n            filter_[\"deal_pipeline_id\"] = deal_pipeline_id\n        if ids is not None:\n            filter_[\"ids\"] = ids\n        if filter_:\n            body[\"filter\"] = filter_\n        resp = self._client._post(\"dealPhases.list\", body)\n        return resp.get(\"data\", [])\n\n    def list_sources(\n        self,\n        *,\n        ids: list[str] | None = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Return all deal sources from the ``dealSources.list`` endpoint.\n\n        Parameters\n        ----------\n        ids:\n            Optional list of source UUIDs to filter by.\n\n        Returns\n        -------\n        list[dict]\n            Raw source dicts as returned by the API (``id``, ``name``).\n        \"\"\"\n        body: dict[str, Any] = {}\n        if ids is not None:\n            body[\"filter\"] = {\"ids\": ids}\n        resp = self._client._post(\"dealSources.list\", body)\n        return resp.get(\"data\", [])\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.deals.DealsResource.move_to_phase","title":"move_to_phase","text":"<pre><code>move_to_phase(deal_id: str, phase_id: str) -&gt; None\n</code></pre> <p>Move a deal to a different pipeline phase.</p> <p>Calls <code>deals.move</code>.</p> <p>Parameters:</p> Name Type Description Default <code>deal_id</code> <code>str</code> <p>UUID of the deal to move.</p> required <code>phase_id</code> <code>str</code> <p>UUID of the target deal phase.</p> required Source code in <code>teamleader/resources/deals.py</code> <pre><code>def move_to_phase(self, deal_id: str, phase_id: str) -&gt; None:\n    \"\"\"Move a deal to a different pipeline phase.\n\n    Calls ``deals.move``.\n\n    Parameters\n    ----------\n    deal_id:\n        UUID of the deal to move.\n    phase_id:\n        UUID of the target deal phase.\n    \"\"\"\n    self._client._post(\"deals.move\", {\"id\": deal_id, \"phase_id\": phase_id})\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.deals.DealsResource.win","title":"win","text":"<pre><code>win(deal_id: str) -&gt; None\n</code></pre> <p>Mark a deal as won.</p> <p>Calls <code>deals.win</code>.</p> <p>Parameters:</p> Name Type Description Default <code>deal_id</code> <code>str</code> <p>UUID of the deal to mark as won.</p> required Source code in <code>teamleader/resources/deals.py</code> <pre><code>def win(self, deal_id: str) -&gt; None:\n    \"\"\"Mark a deal as won.\n\n    Calls ``deals.win``.\n\n    Parameters\n    ----------\n    deal_id:\n        UUID of the deal to mark as won.\n    \"\"\"\n    self._client._post(\"deals.win\", {\"id\": deal_id})\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.deals.DealsResource.lose","title":"lose","text":"<pre><code>lose(\n    deal_id: str,\n    *,\n    reason_id: str | None = None,\n    extra_info: str | None = None\n) -&gt; None\n</code></pre> <p>Mark a deal as lost.</p> <p>Calls <code>deals.lose</code>.</p> <p>Parameters:</p> Name Type Description Default <code>deal_id</code> <code>str</code> <p>UUID of the deal to mark as lost.</p> required <code>reason_id</code> <code>str | None</code> <p>Optional UUID of a configured lost-reason.</p> <code>None</code> <code>extra_info</code> <code>str | None</code> <p>Optional free-text explanation (e.g. <code>\"Too expensive\"</code>).</p> <code>None</code> Source code in <code>teamleader/resources/deals.py</code> <pre><code>def lose(\n    self,\n    deal_id: str,\n    *,\n    reason_id: str | None = None,\n    extra_info: str | None = None,\n) -&gt; None:\n    \"\"\"Mark a deal as lost.\n\n    Calls ``deals.lose``.\n\n    Parameters\n    ----------\n    deal_id:\n        UUID of the deal to mark as lost.\n    reason_id:\n        Optional UUID of a configured lost-reason.\n    extra_info:\n        Optional free-text explanation (e.g. ``\"Too expensive\"``).\n    \"\"\"\n    body: dict[str, Any] = {\"id\": deal_id}\n    if reason_id is not None:\n        body[\"reason_id\"] = reason_id\n    if extra_info is not None:\n        body[\"extra_info\"] = extra_info\n    self._client._post(\"deals.lose\", body)\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.deals.DealsResource.list_phases","title":"list_phases","text":"<pre><code>list_phases(\n    *,\n    deal_pipeline_id: str | None = None,\n    ids: list[str] | None = None\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Return all deal phases from the <code>dealPhases.list</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>deal_pipeline_id</code> <code>str | None</code> <p>Optional UUID \u2014 filter phases to a specific pipeline.</p> <code>None</code> <code>ids</code> <code>list[str] | None</code> <p>Optional list of phase UUIDs to retrieve.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Raw phase dicts as returned by the API (<code>id</code>, <code>name</code>, <code>actions</code>, <code>expected_duration_in_days</code>).</p> Source code in <code>teamleader/resources/deals.py</code> <pre><code>def list_phases(\n    self,\n    *,\n    deal_pipeline_id: str | None = None,\n    ids: list[str] | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Return all deal phases from the ``dealPhases.list`` endpoint.\n\n    Parameters\n    ----------\n    deal_pipeline_id:\n        Optional UUID \u2014 filter phases to a specific pipeline.\n    ids:\n        Optional list of phase UUIDs to retrieve.\n\n    Returns\n    -------\n    list[dict]\n        Raw phase dicts as returned by the API (``id``, ``name``,\n        ``actions``, ``expected_duration_in_days``).\n    \"\"\"\n    body: dict[str, Any] = {}\n    filter_: dict[str, Any] = {}\n    if deal_pipeline_id is not None:\n        filter_[\"deal_pipeline_id\"] = deal_pipeline_id\n    if ids is not None:\n        filter_[\"ids\"] = ids\n    if filter_:\n        body[\"filter\"] = filter_\n    resp = self._client._post(\"dealPhases.list\", body)\n    return resp.get(\"data\", [])\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.deals.DealsResource.list_sources","title":"list_sources","text":"<pre><code>list_sources(\n    *, ids: list[str] | None = None\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Return all deal sources from the <code>dealSources.list</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str] | None</code> <p>Optional list of source UUIDs to filter by.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Raw source dicts as returned by the API (<code>id</code>, <code>name</code>).</p> Source code in <code>teamleader/resources/deals.py</code> <pre><code>def list_sources(\n    self,\n    *,\n    ids: list[str] | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Return all deal sources from the ``dealSources.list`` endpoint.\n\n    Parameters\n    ----------\n    ids:\n        Optional list of source UUIDs to filter by.\n\n    Returns\n    -------\n    list[dict]\n        Raw source dicts as returned by the API (``id``, ``name``).\n    \"\"\"\n    body: dict[str, Any] = {}\n    if ids is not None:\n        body[\"filter\"] = {\"ids\": ids}\n    resp = self._client._post(\"dealSources.list\", body)\n    return resp.get(\"data\", [])\n</code></pre>"},{"location":"api-reference/resources/#invoices","title":"Invoices","text":""},{"location":"api-reference/resources/#teamleader.resources.invoices.InvoicesResource","title":"InvoicesResource","text":"<p>               Bases: <code>CrudResource[Invoice]</code></p> <p>CRUD + extra actions for Teamleader invoices.</p> <p>Inherits :meth:<code>list</code>, :meth:<code>get</code>, :meth:<code>create</code>, :meth:<code>update</code>, :meth:<code>delete</code>, and :meth:<code>iterate</code> from :class:<code>~teamleader.resources.base.CrudResource</code>.</p> Source code in <code>teamleader/resources/invoices.py</code> <pre><code>class InvoicesResource(CrudResource[Invoice]):\n    \"\"\"CRUD + extra actions for Teamleader invoices.\n\n    Inherits :meth:`list`, :meth:`get`, :meth:`create`, :meth:`update`,\n    :meth:`delete`, and :meth:`iterate` from :class:`~teamleader.resources.base.CrudResource`.\n    \"\"\"\n\n    prefix = \"invoices\"\n    model = Invoice\n\n    def book(self, invoice_id: str, on: str) -&gt; None:\n        \"\"\"Book a draft invoice, turning it into a numbered invoice.\n\n        Calls ``invoices.book``.\n\n        Parameters\n        ----------\n        invoice_id:\n            UUID of the draft invoice to book.\n        on:\n            Invoice date as an ISO 8601 date string (``\"YYYY-MM-DD\"``).\n            This becomes the ``invoice_date`` on the booked invoice.\n        \"\"\"\n        self._client._post(\"invoices.book\", {\"id\": invoice_id, \"on\": on})\n\n    def credit(\n        self,\n        invoice_id: str,\n        *,\n        credit_note_date: str | None = None,\n    ) -&gt; TypeAndId:\n        \"\"\"Credit an invoice completely, creating a credit note.\n\n        Calls ``invoices.credit``.  Returns a :class:`~teamleader.models.common.TypeAndId`\n        reference to the newly created credit note (``type=\"creditNote\"``).\n\n        Parameters\n        ----------\n        invoice_id:\n            UUID of the booked invoice to credit.\n        credit_note_date:\n            Optional ISO 8601 date string for the credit note.  Defaults to\n            the current date when omitted.\n\n        Returns\n        -------\n        TypeAndId\n            Reference to the credit note created by the API.\n        \"\"\"\n        body: dict[str, Any] = {\"id\": invoice_id}\n        if credit_note_date is not None:\n            body[\"credit_note_date\"] = credit_note_date\n        resp = self._client._post(\"invoices.credit\", body)\n        return TypeAndId.from_api(resp[\"data\"])\n\n    def register_payment(\n        self,\n        invoice_id: str,\n        payment: Money,\n        paid_at: str,\n        *,\n        payment_method_id: str | None = None,\n    ) -&gt; None:\n        \"\"\"Register a payment against an invoice.\n\n        Calls ``invoices.registerPayment``.\n\n        Parameters\n        ----------\n        invoice_id:\n            UUID of the invoice being paid.\n        payment:\n            The amount paid as a :class:`~teamleader.models.common.Money` object.\n        paid_at:\n            ISO 8601 datetime at which the payment was received\n            (e.g. ``\"2016-03-03T16:44:33+00:00\"``).\n        payment_method_id:\n            Optional UUID of a configured payment method.\n        \"\"\"\n        body: dict[str, Any] = {\n            \"id\": invoice_id,\n            \"payment\": payment.to_dict(),\n            \"paid_at\": paid_at,\n        }\n        if payment_method_id is not None:\n            body[\"payment_method_id\"] = payment_method_id\n        self._client._post(\"invoices.registerPayment\", body)\n\n    def send(\n        self,\n        invoice_id: str,\n        subject: str,\n        body: str,\n        *,\n        mail_template_id: str | None = None,\n        recipients: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Send an invoice to the invoicee via e-mail.\n\n        Calls ``invoices.send``.\n\n        Parameters\n        ----------\n        invoice_id:\n            UUID of the invoice to send.\n        subject:\n            E-mail subject line.\n        body:\n            E-mail body text.\n        mail_template_id:\n            Optional UUID of a mail template to use.\n        recipients:\n            Optional ``{\"to\": [...], \"cc\": [...]}`` dict overriding the default\n            recipients.  Each entry is ``{\"email\": \"...\", \"customer\": {...}}``.\n        \"\"\"\n        content: dict[str, Any] = {\"subject\": subject, \"body\": body}\n        if mail_template_id is not None:\n            content[\"mail_template_id\"] = mail_template_id\n\n        payload: dict[str, Any] = {\"id\": invoice_id, \"content\": content}\n        if recipients is not None:\n            payload[\"recipients\"] = recipients\n        self._client._post(\"invoices.send\", payload)\n\n    def download(\n        self,\n        invoice_id: str,\n        format: str = \"pdf\",\n    ) -&gt; dict[str, str]:\n        \"\"\"Request a download URL for an invoice document.\n\n        Calls ``invoices.download``.  The API returns a pre-signed URL that\n        expires after a short time.\n\n        Parameters\n        ----------\n        invoice_id:\n            UUID of the invoice to download.\n        format:\n            Document format \u2014 ``\"pdf\"`` (default), ``\"ubl/e-fff\"``, or\n            ``\"ubl/peppol_bis_3\"``.\n\n        Returns\n        -------\n        dict\n            ``{\"location\": \"&lt;pre-signed URL&gt;\", \"expires\": \"&lt;ISO datetime&gt;\"}``\n        \"\"\"\n        resp = self._client._post(\n            \"invoices.download\", {\"id\": invoice_id, \"format\": format}\n        )\n        return resp[\"data\"]\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.invoices.InvoicesResource.book","title":"book","text":"<pre><code>book(invoice_id: str, on: str) -&gt; None\n</code></pre> <p>Book a draft invoice, turning it into a numbered invoice.</p> <p>Calls <code>invoices.book</code>.</p> <p>Parameters:</p> Name Type Description Default <code>invoice_id</code> <code>str</code> <p>UUID of the draft invoice to book.</p> required <code>on</code> <code>str</code> <p>Invoice date as an ISO 8601 date string (<code>\"YYYY-MM-DD\"</code>). This becomes the <code>invoice_date</code> on the booked invoice.</p> required Source code in <code>teamleader/resources/invoices.py</code> <pre><code>def book(self, invoice_id: str, on: str) -&gt; None:\n    \"\"\"Book a draft invoice, turning it into a numbered invoice.\n\n    Calls ``invoices.book``.\n\n    Parameters\n    ----------\n    invoice_id:\n        UUID of the draft invoice to book.\n    on:\n        Invoice date as an ISO 8601 date string (``\"YYYY-MM-DD\"``).\n        This becomes the ``invoice_date`` on the booked invoice.\n    \"\"\"\n    self._client._post(\"invoices.book\", {\"id\": invoice_id, \"on\": on})\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.invoices.InvoicesResource.credit","title":"credit","text":"<pre><code>credit(\n    invoice_id: str, *, credit_note_date: str | None = None\n) -&gt; TypeAndId\n</code></pre> <p>Credit an invoice completely, creating a credit note.</p> <p>Calls <code>invoices.credit</code>.  Returns a :class:<code>~teamleader.models.common.TypeAndId</code> reference to the newly created credit note (<code>type=\"creditNote\"</code>).</p> <p>Parameters:</p> Name Type Description Default <code>invoice_id</code> <code>str</code> <p>UUID of the booked invoice to credit.</p> required <code>credit_note_date</code> <code>str | None</code> <p>Optional ISO 8601 date string for the credit note.  Defaults to the current date when omitted.</p> <code>None</code> <p>Returns:</p> Type Description <code>TypeAndId</code> <p>Reference to the credit note created by the API.</p> Source code in <code>teamleader/resources/invoices.py</code> <pre><code>def credit(\n    self,\n    invoice_id: str,\n    *,\n    credit_note_date: str | None = None,\n) -&gt; TypeAndId:\n    \"\"\"Credit an invoice completely, creating a credit note.\n\n    Calls ``invoices.credit``.  Returns a :class:`~teamleader.models.common.TypeAndId`\n    reference to the newly created credit note (``type=\"creditNote\"``).\n\n    Parameters\n    ----------\n    invoice_id:\n        UUID of the booked invoice to credit.\n    credit_note_date:\n        Optional ISO 8601 date string for the credit note.  Defaults to\n        the current date when omitted.\n\n    Returns\n    -------\n    TypeAndId\n        Reference to the credit note created by the API.\n    \"\"\"\n    body: dict[str, Any] = {\"id\": invoice_id}\n    if credit_note_date is not None:\n        body[\"credit_note_date\"] = credit_note_date\n    resp = self._client._post(\"invoices.credit\", body)\n    return TypeAndId.from_api(resp[\"data\"])\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.invoices.InvoicesResource.register_payment","title":"register_payment","text":"<pre><code>register_payment(\n    invoice_id: str,\n    payment: Money,\n    paid_at: str,\n    *,\n    payment_method_id: str | None = None\n) -&gt; None\n</code></pre> <p>Register a payment against an invoice.</p> <p>Calls <code>invoices.registerPayment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>invoice_id</code> <code>str</code> <p>UUID of the invoice being paid.</p> required <code>payment</code> <code>Money</code> <p>The amount paid as a :class:<code>~teamleader.models.common.Money</code> object.</p> required <code>paid_at</code> <code>str</code> <p>ISO 8601 datetime at which the payment was received (e.g. <code>\"2016-03-03T16:44:33+00:00\"</code>).</p> required <code>payment_method_id</code> <code>str | None</code> <p>Optional UUID of a configured payment method.</p> <code>None</code> Source code in <code>teamleader/resources/invoices.py</code> <pre><code>def register_payment(\n    self,\n    invoice_id: str,\n    payment: Money,\n    paid_at: str,\n    *,\n    payment_method_id: str | None = None,\n) -&gt; None:\n    \"\"\"Register a payment against an invoice.\n\n    Calls ``invoices.registerPayment``.\n\n    Parameters\n    ----------\n    invoice_id:\n        UUID of the invoice being paid.\n    payment:\n        The amount paid as a :class:`~teamleader.models.common.Money` object.\n    paid_at:\n        ISO 8601 datetime at which the payment was received\n        (e.g. ``\"2016-03-03T16:44:33+00:00\"``).\n    payment_method_id:\n        Optional UUID of a configured payment method.\n    \"\"\"\n    body: dict[str, Any] = {\n        \"id\": invoice_id,\n        \"payment\": payment.to_dict(),\n        \"paid_at\": paid_at,\n    }\n    if payment_method_id is not None:\n        body[\"payment_method_id\"] = payment_method_id\n    self._client._post(\"invoices.registerPayment\", body)\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.invoices.InvoicesResource.send","title":"send","text":"<pre><code>send(\n    invoice_id: str,\n    subject: str,\n    body: str,\n    *,\n    mail_template_id: str | None = None,\n    recipients: dict[str, Any] | None = None\n) -&gt; None\n</code></pre> <p>Send an invoice to the invoicee via e-mail.</p> <p>Calls <code>invoices.send</code>.</p> <p>Parameters:</p> Name Type Description Default <code>invoice_id</code> <code>str</code> <p>UUID of the invoice to send.</p> required <code>subject</code> <code>str</code> <p>E-mail subject line.</p> required <code>body</code> <code>str</code> <p>E-mail body text.</p> required <code>mail_template_id</code> <code>str | None</code> <p>Optional UUID of a mail template to use.</p> <code>None</code> <code>recipients</code> <code>dict[str, Any] | None</code> <p>Optional <code>{\"to\": [...], \"cc\": [...]}</code> dict overriding the default recipients.  Each entry is <code>{\"email\": \"...\", \"customer\": {...}}</code>.</p> <code>None</code> Source code in <code>teamleader/resources/invoices.py</code> <pre><code>def send(\n    self,\n    invoice_id: str,\n    subject: str,\n    body: str,\n    *,\n    mail_template_id: str | None = None,\n    recipients: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Send an invoice to the invoicee via e-mail.\n\n    Calls ``invoices.send``.\n\n    Parameters\n    ----------\n    invoice_id:\n        UUID of the invoice to send.\n    subject:\n        E-mail subject line.\n    body:\n        E-mail body text.\n    mail_template_id:\n        Optional UUID of a mail template to use.\n    recipients:\n        Optional ``{\"to\": [...], \"cc\": [...]}`` dict overriding the default\n        recipients.  Each entry is ``{\"email\": \"...\", \"customer\": {...}}``.\n    \"\"\"\n    content: dict[str, Any] = {\"subject\": subject, \"body\": body}\n    if mail_template_id is not None:\n        content[\"mail_template_id\"] = mail_template_id\n\n    payload: dict[str, Any] = {\"id\": invoice_id, \"content\": content}\n    if recipients is not None:\n        payload[\"recipients\"] = recipients\n    self._client._post(\"invoices.send\", payload)\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.invoices.InvoicesResource.download","title":"download","text":"<pre><code>download(\n    invoice_id: str, format: str = \"pdf\"\n) -&gt; dict[str, str]\n</code></pre> <p>Request a download URL for an invoice document.</p> <p>Calls <code>invoices.download</code>.  The API returns a pre-signed URL that expires after a short time.</p> <p>Parameters:</p> Name Type Description Default <code>invoice_id</code> <code>str</code> <p>UUID of the invoice to download.</p> required <code>format</code> <code>str</code> <p>Document format \u2014 <code>\"pdf\"</code> (default), <code>\"ubl/e-fff\"</code>, or <code>\"ubl/peppol_bis_3\"</code>.</p> <code>'pdf'</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>{\"location\": \"&lt;pre-signed URL&gt;\", \"expires\": \"&lt;ISO datetime&gt;\"}</code></p> Source code in <code>teamleader/resources/invoices.py</code> <pre><code>def download(\n    self,\n    invoice_id: str,\n    format: str = \"pdf\",\n) -&gt; dict[str, str]:\n    \"\"\"Request a download URL for an invoice document.\n\n    Calls ``invoices.download``.  The API returns a pre-signed URL that\n    expires after a short time.\n\n    Parameters\n    ----------\n    invoice_id:\n        UUID of the invoice to download.\n    format:\n        Document format \u2014 ``\"pdf\"`` (default), ``\"ubl/e-fff\"``, or\n        ``\"ubl/peppol_bis_3\"``.\n\n    Returns\n    -------\n    dict\n        ``{\"location\": \"&lt;pre-signed URL&gt;\", \"expires\": \"&lt;ISO datetime&gt;\"}``\n    \"\"\"\n    resp = self._client._post(\n        \"invoices.download\", {\"id\": invoice_id, \"format\": format}\n    )\n    return resp[\"data\"]\n</code></pre>"},{"location":"api-reference/resources/#quotations","title":"Quotations","text":""},{"location":"api-reference/resources/#teamleader.resources.quotations.QuotationsResource","title":"QuotationsResource","text":"<p>               Bases: <code>CrudResource[Quotation]</code></p> <p>CRUD + extra actions for Teamleader quotations.</p> <p>Inherits :meth:<code>list</code>, :meth:<code>get</code>, :meth:<code>create</code>, :meth:<code>update</code>, :meth:<code>delete</code>, and :meth:<code>iterate</code> from :class:<code>~teamleader.resources.base.CrudResource</code>.</p> Source code in <code>teamleader/resources/quotations.py</code> <pre><code>class QuotationsResource(CrudResource[Quotation]):\n    \"\"\"CRUD + extra actions for Teamleader quotations.\n\n    Inherits :meth:`list`, :meth:`get`, :meth:`create`, :meth:`update`,\n    :meth:`delete`, and :meth:`iterate` from :class:`~teamleader.resources.base.CrudResource`.\n    \"\"\"\n\n    prefix = \"quotations\"\n    model = Quotation\n\n    def send(\n        self,\n        quotation_ids: list[str],\n        recipients: dict[str, Any],\n        subject: str,\n        content: str,\n        language: str,\n        *,\n        from_: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Send one or more quotations from the same deal via e-mail.\n\n        Calls ``quotations.send``.\n\n        All ``quotation_ids`` must belong to the same deal.\n\n        Parameters\n        ----------\n        quotation_ids:\n            List of quotation UUIDs to send in a single e-mail.\n        recipients:\n            Recipient dict with a required ``\"to\"`` key and optional ``\"cc\"``\n            key.  Each entry in the list is\n            ``{\"email_address\": \"...\", \"customer\": {...}}``.\n\n            Example::\n\n                {\n                    \"to\": [{\"email_address\": \"client@example.com\"}],\n                    \"cc\": [{\"email_address\": \"internal@acme.com\"}],\n                }\n\n        subject:\n            E-mail subject line.\n        content:\n            E-mail body text (plain-text or Markdown).\n        language:\n            ISO 639-1 language code for the e-mail (e.g. ``\"en\"``, ``\"nl\"``).\n        from_:\n            Optional sender override::\n\n                {\n                    \"sender\": {\"type\": \"user\", \"id\": \"&lt;uuid&gt;\"},\n                    \"email_address\": \"sender@acme.com\",\n                }\n        \"\"\"\n        body: dict[str, Any] = {\n            \"quotations\": quotation_ids,\n            \"recipients\": recipients,\n            \"subject\": subject,\n            \"content\": content,\n            \"language\": language,\n        }\n        if from_ is not None:\n            body[\"from\"] = from_\n        self._client._post(\"quotations.send\", body)\n\n    def accept(self, quotation_id: str) -&gt; None:\n        \"\"\"Mark a quotation as accepted.\n\n        Calls ``quotations.accept``.\n\n        Parameters\n        ----------\n        quotation_id:\n            UUID of the quotation to accept.\n        \"\"\"\n        self._client._post(\"quotations.accept\", {\"id\": quotation_id})\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.quotations.QuotationsResource.send","title":"send","text":"<pre><code>send(\n    quotation_ids: list[str],\n    recipients: dict[str, Any],\n    subject: str,\n    content: str,\n    language: str,\n    *,\n    from_: dict[str, Any] | None = None\n) -&gt; None\n</code></pre> <p>Send one or more quotations from the same deal via e-mail.</p> <p>Calls <code>quotations.send</code>.</p> <p>All <code>quotation_ids</code> must belong to the same deal.</p> <p>Parameters:</p> Name Type Description Default <code>quotation_ids</code> <code>list[str]</code> <p>List of quotation UUIDs to send in a single e-mail.</p> required <code>recipients</code> <code>dict[str, Any]</code> <p>Recipient dict with a required <code>\"to\"</code> key and optional <code>\"cc\"</code> key.  Each entry in the list is <code>{\"email_address\": \"...\", \"customer\": {...}}</code>.</p> <p>Example::</p> <pre><code>{\n    \"to\": [{\"email_address\": \"client@example.com\"}],\n    \"cc\": [{\"email_address\": \"internal@acme.com\"}],\n}\n</code></pre> required <code>subject</code> <code>str</code> <p>E-mail subject line.</p> required <code>content</code> <code>str</code> <p>E-mail body text (plain-text or Markdown).</p> required <code>language</code> <code>str</code> <p>ISO 639-1 language code for the e-mail (e.g. <code>\"en\"</code>, <code>\"nl\"</code>).</p> required <code>from_</code> <code>dict[str, Any] | None</code> <p>Optional sender override::</p> <pre><code>{\n    \"sender\": {\"type\": \"user\", \"id\": \"&lt;uuid&gt;\"},\n    \"email_address\": \"sender@acme.com\",\n}\n</code></pre> <code>None</code> Source code in <code>teamleader/resources/quotations.py</code> <pre><code>def send(\n    self,\n    quotation_ids: list[str],\n    recipients: dict[str, Any],\n    subject: str,\n    content: str,\n    language: str,\n    *,\n    from_: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Send one or more quotations from the same deal via e-mail.\n\n    Calls ``quotations.send``.\n\n    All ``quotation_ids`` must belong to the same deal.\n\n    Parameters\n    ----------\n    quotation_ids:\n        List of quotation UUIDs to send in a single e-mail.\n    recipients:\n        Recipient dict with a required ``\"to\"`` key and optional ``\"cc\"``\n        key.  Each entry in the list is\n        ``{\"email_address\": \"...\", \"customer\": {...}}``.\n\n        Example::\n\n            {\n                \"to\": [{\"email_address\": \"client@example.com\"}],\n                \"cc\": [{\"email_address\": \"internal@acme.com\"}],\n            }\n\n    subject:\n        E-mail subject line.\n    content:\n        E-mail body text (plain-text or Markdown).\n    language:\n        ISO 639-1 language code for the e-mail (e.g. ``\"en\"``, ``\"nl\"``).\n    from_:\n        Optional sender override::\n\n            {\n                \"sender\": {\"type\": \"user\", \"id\": \"&lt;uuid&gt;\"},\n                \"email_address\": \"sender@acme.com\",\n            }\n    \"\"\"\n    body: dict[str, Any] = {\n        \"quotations\": quotation_ids,\n        \"recipients\": recipients,\n        \"subject\": subject,\n        \"content\": content,\n        \"language\": language,\n    }\n    if from_ is not None:\n        body[\"from\"] = from_\n    self._client._post(\"quotations.send\", body)\n</code></pre>"},{"location":"api-reference/resources/#teamleader.resources.quotations.QuotationsResource.accept","title":"accept","text":"<pre><code>accept(quotation_id: str) -&gt; None\n</code></pre> <p>Mark a quotation as accepted.</p> <p>Calls <code>quotations.accept</code>.</p> <p>Parameters:</p> Name Type Description Default <code>quotation_id</code> <code>str</code> <p>UUID of the quotation to accept.</p> required Source code in <code>teamleader/resources/quotations.py</code> <pre><code>def accept(self, quotation_id: str) -&gt; None:\n    \"\"\"Mark a quotation as accepted.\n\n    Calls ``quotations.accept``.\n\n    Parameters\n    ----------\n    quotation_id:\n        UUID of the quotation to accept.\n    \"\"\"\n    self._client._post(\"quotations.accept\", {\"id\": quotation_id})\n</code></pre>"},{"location":"guides/django/","title":"Django Integration","text":"<p>The <code>teamleader.django</code> sub-package provides a <code>DatabaseTokenBackend</code> that stores OAuth2 tokens in your Django database, and a <code>teamleader_setup</code> management command that automates the initial OAuth handshake.</p>"},{"location":"guides/django/#1-install-the-django-extra","title":"1. Install the Django extra","text":"<pre><code>pip install teamleader-sdk[django]\n</code></pre>"},{"location":"guides/django/#2-add-to-installed_apps","title":"2. Add to <code>INSTALLED_APPS</code>","text":"<pre><code># settings.py\nINSTALLED_APPS = [\n    ...\n    \"teamleader.django\",\n]\n</code></pre> <p><code>TeamleaderConfig.ready()</code> validates all required settings keys on startup and raises <code>django.core.exceptions.ImproperlyConfigured</code> with an actionable message if any are missing.</p>"},{"location":"guides/django/#3-configure-the-teamleader-settings-dict","title":"3. Configure the <code>TEAMLEADER</code> settings dict","text":"<pre><code># settings.py\nTEAMLEADER = {\n    # Required\n    \"CLIENT_ID\":     \"your-client-id\",\n    \"CLIENT_SECRET\": \"your-client-secret\",\n    \"REDIRECT_URI\":  \"http://localhost:9999/callback\",  # must match your Marketplace app\n    \"SCOPES\":        [\"contacts\", \"deals\"],\n\n    # Optional \u2014 defaults shown\n    \"OAUTH_CALLBACK_PORT\": 9999,   # port for the setup command's local HTTP server\n    \"TOKEN_BACKEND\":       \"teamleader.django.token_store.DatabaseTokenBackend\",\n    \"TIMEOUT\":             30,     # HTTP request timeout in seconds\n}\n</code></pre>"},{"location":"guides/django/#required-keys","title":"Required keys","text":"Key Description <code>CLIENT_ID</code> OAuth2 client ID from Teamleader Marketplace <code>CLIENT_SECRET</code> OAuth2 client secret <code>REDIRECT_URI</code> Must exactly match the Redirect URI configured in the Marketplace app <code>SCOPES</code> List of OAuth scope strings your app needs"},{"location":"guides/django/#optional-keys","title":"Optional keys","text":"Key Default Description <code>OAUTH_CALLBACK_PORT</code> <code>9999</code> Port for the <code>teamleader_setup</code> local HTTP server <code>TOKEN_BACKEND</code> <code>DatabaseTokenBackend</code> (dotted path) Custom token storage backend <code>TIMEOUT</code> <code>30</code> HTTP request timeout in seconds"},{"location":"guides/django/#4-create-the-token-table","title":"4. Create the token table","text":"<p>The SDK does not ship migrations.  Run <code>makemigrations</code> once per downstream project:</p> <pre><code>python manage.py makemigrations teamleader_django\npython manage.py migrate\n</code></pre> <p>This creates the <code>TeamleaderToken</code> singleton table that <code>DatabaseTokenBackend</code> uses.</p>"},{"location":"guides/django/#5-obtain-oauth-tokens","title":"5. Obtain OAuth tokens","text":"<pre><code>python manage.py teamleader_setup\n</code></pre> <p>The command:</p> <ol> <li>Validates your <code>TEAMLEADER</code> settings dict</li> <li>Builds the authorization URL via <code>OAuth2Handler.get_authorization_url()</code></li> <li>Prints the URL \u2014 open it in a browser and authorise the app</li> <li>Starts a temporary HTTP server on <code>OAUTH_CALLBACK_PORT</code> (default 9999)</li> <li>Captures the <code>?code=\u2026</code> callback</li> <li>Exchanges the code for an access + refresh token pair</li> <li>Saves both tokens in the database via <code>DatabaseTokenBackend</code></li> <li>Prints a confirmation with the access-token expiry time</li> </ol>"},{"location":"guides/django/#6-use-the-client-in-your-code","title":"6. Use the client in your code","text":"<pre><code>from teamleader.django import get_client\n\nclient = get_client()\n\n# The client automatically refreshes expired access tokens using the stored\n# refresh token \u2014 no manual token management needed.\n\n# Iterate over all contacts\nfor contact in client.contacts.iterate():\n    print(contact.full_name, contact.primary_email)\n\n# Fetch a single deal by UUID\ndeal = client.deals.get(\"c3dea2c8-dad9-4834-8a49-e16b5c5f1dde\")\nprint(deal.title, deal.is_won)\n</code></pre> <p><code>get_client()</code> reads <code>settings.TEAMLEADER</code>, constructs a <code>DatabaseTokenBackend</code> and <code>OAuth2Handler</code>, and returns a fully configured <code>TeamleaderClient</code>.</p>"},{"location":"guides/django/#token-storage-details","title":"Token storage details","text":"<p><code>DatabaseTokenBackend</code> uses <code>select_for_update()</code> inside <code>transaction.atomic()</code> on every <code>save()</code> to prevent race conditions in multi-worker/multi-process deployments (gunicorn, uWSGI, Celery, etc.).</p> <p>The <code>TeamleaderToken</code> model enforces a singleton by pinning <code>pk = 1</code> before every <code>save()</code>.  There is always at most one token row in the database.</p>"},{"location":"guides/django/#token-rotation","title":"Token rotation","text":"<p>Teamleader uses refresh-token rotation: every successful token refresh invalidates the old refresh token and issues a new pair.  <code>DatabaseTokenBackend.save()</code> updates both <code>access_token</code> and <code>refresh_token</code> atomically on each refresh, so subsequent requests in the same process always see the latest credentials.</p> <p>Re-run <code>teamleader_setup</code> if the refresh token is revoked</p> <p>If the refresh token is revoked (e.g. the Marketplace app is re-authorised), <code>TeamleaderAuthExpiredError</code> will be raised.  Re-run <code>teamleader_setup</code> to obtain a fresh token pair.</p>"},{"location":"guides/error-handling/","title":"Error Handling","text":"<p>All exceptions raised by the SDK inherit from <code>TeamleaderError</code>, so you can catch the broadest class you care about, or handle specific errors individually.</p>"},{"location":"guides/error-handling/#exception-hierarchy","title":"Exception hierarchy","text":"<pre><code>TeamleaderError\n\u251c\u2500\u2500 TeamleaderAPIError              non-specific 4xx response\n\u2502   \u251c\u2500\u2500 TeamleaderNotFoundError     404 \u2014 resource not found\n\u2502   \u251c\u2500\u2500 TeamleaderRateLimitError    429 \u2014 rate limit exceeded (adds .retry_after)\n\u2502   \u2514\u2500\u2500 TeamleaderServerError       5xx \u2014 server-side error\n\u251c\u2500\u2500 TeamleaderAuthError             401 \u2014 access token invalid / missing\n\u2502   \u2514\u2500\u2500 TeamleaderAuthExpiredError  refresh token revoked or expired\n\u251c\u2500\u2500 TeamleaderValidationError       422 \u2014 request body failed validation\n\u2514\u2500\u2500 TeamleaderPermissionError       403 \u2014 insufficient OAuth scope\n</code></pre> <p>Every exception carries three attributes:</p> Attribute Type Description <code>message</code> <code>str</code> Human-readable error message extracted from the API response <code>status_code</code> <code>int \\| None</code> HTTP status code <code>raw_response</code> <code>requests.Response \\| None</code> Full response object for advanced inspection <p><code>TeamleaderRateLimitError</code> adds a fourth:</p> Attribute Type Description <code>retry_after</code> <code>int \\| None</code> Seconds to wait before retrying (from <code>Retry-After</code> header)"},{"location":"guides/error-handling/#usage-patterns","title":"Usage patterns","text":""},{"location":"guides/error-handling/#catch-specific-errors","title":"Catch specific errors","text":"<pre><code>import time\nfrom teamleader.exceptions import (\n    TeamleaderNotFoundError,\n    TeamleaderRateLimitError,\n    TeamleaderAuthExpiredError,\n    TeamleaderPermissionError,\n    TeamleaderValidationError,\n    TeamleaderError,\n)\n\ntry:\n    deal = client.deals.get(\"non-existent-uuid\")\n\nexcept TeamleaderNotFoundError:\n    print(\"Deal does not exist\")\n\nexcept TeamleaderRateLimitError as e:\n    wait = e.retry_after or 60\n    print(f\"Rate limited \u2014 retrying in {wait}s\")\n    time.sleep(wait)\n\nexcept TeamleaderAuthExpiredError:\n    # Refresh token has been revoked \u2014 must re-authorise\n    print(\"Re-run `python manage.py teamleader_setup` to re-authorise\")\n\nexcept TeamleaderPermissionError:\n    # OAuth scope missing \u2014 check your SCOPES setting\n    print(f\"Missing scope: {e.message}\")\n\nexcept TeamleaderValidationError as e:\n    print(f\"Bad request: {e.message}\")\n\nexcept TeamleaderError as e:\n    # Catch-all for any SDK error\n    print(f\"SDK error {e.status_code}: {e.message}\")\n</code></pre>"},{"location":"guides/error-handling/#broad-catch-all","title":"Broad catch-all","text":"<pre><code>from teamleader.exceptions import TeamleaderError\n\ntry:\n    client.invoices.book(invoice_id, on=\"2025-03-01\")\nexcept TeamleaderError as e:\n    logger.error(\"Teamleader API error\", extra={\n        \"status_code\": e.status_code,\n        \"message\": e.message,\n    })\n    raise\n</code></pre>"},{"location":"guides/error-handling/#rate-limit-retry-loop","title":"Rate-limit retry loop","text":"<pre><code>import time\nfrom teamleader.exceptions import TeamleaderRateLimitError\n\nMAX_RETRIES = 3\nattempt = 0\n\nwhile attempt &lt; MAX_RETRIES:\n    try:\n        page = client.contacts.list(page=1, page_size=100)\n        break\n    except TeamleaderRateLimitError as e:\n        attempt += 1\n        if attempt &gt;= MAX_RETRIES:\n            raise\n        wait = e.retry_after or (2 ** attempt)\n        time.sleep(wait)\n</code></pre>"},{"location":"guides/error-handling/#auth-errors-vs-api-errors","title":"Auth errors vs. API errors","text":"Exception When raised Action <code>TeamleaderAuthError</code> 401 response Access token invalid \u2014 the SDK will attempt a refresh automatically for the next request; this is raised when the explicit token fetch fails <code>TeamleaderAuthExpiredError</code> Refresh grant rejected Re-run <code>teamleader_setup</code> or <code>get_tokens.py</code> to obtain a new token pair <code>TeamleaderPermissionError</code> 403 response The OAuth app lacks the required scope \u2014 update <code>SCOPES</code> in settings and re-authorise <p>Tip</p> <p>Transparent token refresh happens inside <code>OAuth2Handler.get_valid_token()</code> \u2014 called automatically before every request.  You only see <code>TeamleaderAuthExpiredError</code> if the refresh grant itself fails (revoked token, app re-authorised, etc.).</p>"},{"location":"guides/non-django/","title":"Non-Django Usage","text":"<p>The core SDK has no Django dependency.  Use it in FastAPI services, Celery workers, CLI scripts, or any other Python environment.</p>"},{"location":"guides/non-django/#1-obtain-credentials","title":"1. Obtain credentials","text":"<p>Run the standalone helper once on a dev machine to get an initial token pair:</p> <pre><code>python get_tokens.py\n</code></pre> <p>The script opens the Teamleader OAuth flow in a browser, captures the callback on <code>localhost:9999</code>, exchanges the code, and prints a <code>.env</code> block:</p> <pre><code>TEAMLEADER_ACCESS_TOKEN=eyJhbGci...\nTEAMLEADER_REFRESH_TOKEN=def5020...\nTEAMLEADER_EXPIRES_AT=2025-06-01T12:00:00+00:00\n</code></pre> <p>Save this to a <code>.env</code> file (already in <code>.gitignore</code>).</p>"},{"location":"guides/non-django/#2-build-the-client","title":"2. Build the client","text":"<pre><code>from datetime import datetime, timezone\nfrom teamleader import TeamleaderClient, OAuth2Handler, MemoryTokenBackend, Token\n\n# 1. Create a backend and load the stored token\nbackend = MemoryTokenBackend()\nbackend.save(Token(\n    access_token=\"&lt;access-token&gt;\",\n    refresh_token=\"&lt;refresh-token&gt;\",\n    expires_at=datetime(2025, 12, 31, tzinfo=timezone.utc),\n))\n\n# 2. Create an auth handler\nhandler = OAuth2Handler(\n    client_id=\"your-client-id\",\n    client_secret=\"your-client-secret\",\n    redirect_uri=\"http://localhost:9999/callback\",\n    token_backend=backend,\n)\n\n# 3. Create the client\nclient = TeamleaderClient(handler)\n\n# 4. Use it\ninvoice = client.invoices.get(\"e540fe7e-dce2-459e-bf7e-24e605fc18b3\")\nprint(invoice.invoice_number, invoice.is_overdue)\n</code></pre>"},{"location":"guides/non-django/#3-loading-tokens-from-environment-variables","title":"3. Loading tokens from environment variables","text":"<pre><code>import os\nfrom datetime import datetime, timezone\nfrom dotenv import load_dotenv\nfrom teamleader import TeamleaderClient, OAuth2Handler, MemoryTokenBackend, Token\n\nload_dotenv()  # reads .env file\n\nbackend = MemoryTokenBackend()\nbackend.save(Token(\n    access_token=os.environ[\"TEAMLEADER_ACCESS_TOKEN\"],\n    refresh_token=os.environ[\"TEAMLEADER_REFRESH_TOKEN\"],\n    expires_at=datetime.fromisoformat(os.environ[\"TEAMLEADER_EXPIRES_AT\"]),\n))\n\nhandler = OAuth2Handler(\n    client_id=os.environ[\"TEAMLEADER_CLIENT_ID\"],\n    client_secret=os.environ[\"TEAMLEADER_CLIENT_SECRET\"],\n    redirect_uri=os.environ[\"TEAMLEADER_REDIRECT_URI\"],\n    token_backend=backend,\n)\n\nclient = TeamleaderClient(handler)\n</code></pre>"},{"location":"guides/non-django/#4-custom-token-backend","title":"4. Custom token backend","text":"<p>Implement <code>TokenBackend</code> to persist tokens in Redis, a file, or any other store:</p> <pre><code>from teamleader.auth import TokenBackend, Token\nimport json, pathlib\n\nclass FileTokenBackend(TokenBackend):\n    def __init__(self, path: str) -&gt; None:\n        self._path = pathlib.Path(path)\n\n    def get(self) -&gt; Token | None:\n        if not self._path.exists():\n            return None\n        data = json.loads(self._path.read_text())\n        from datetime import datetime\n        return Token(\n            access_token=data[\"access_token\"],\n            refresh_token=data[\"refresh_token\"],\n            expires_at=datetime.fromisoformat(data[\"expires_at\"]),\n        )\n\n    def save(self, token: Token) -&gt; None:\n        self._path.write_text(json.dumps({\n            \"access_token\":  token.access_token,\n            \"refresh_token\": token.refresh_token,\n            \"expires_at\":    token.expires_at.isoformat(),\n        }))\n\n    def clear(self) -&gt; None:\n        self._path.unlink(missing_ok=True)\n</code></pre> <p>Pass it to <code>OAuth2Handler</code> the same way as <code>MemoryTokenBackend</code>.</p>"},{"location":"guides/non-django/#token-refresh-behaviour","title":"Token refresh behaviour","text":"<p><code>TeamleaderClient</code> calls <code>OAuth2Handler.get_valid_token()</code> before every request. If the stored <code>Token.is_expired</code> returns <code>True</code>, the handler transparently issues a refresh-token grant and saves the new pair via the backend.  The original request then proceeds with the fresh access token \u2014 no manual refresh logic required.</p> <p>A safety margin of 60 seconds is applied: tokens are considered expired 60 s before their actual <code>expires_at</code> so in-flight requests are never rejected mid-call.</p> <p>Refresh token revocation</p> <p>If Teamleader revokes the refresh token (app re-authorised, long inactivity), <code>TeamleaderAuthExpiredError</code> is raised.  Re-run <code>get_tokens.py</code> to obtain a new pair.</p>"},{"location":"guides/resources/","title":"Working with Resources","text":"<p>Every resource on <code>TeamleaderClient</code> exposes the same five CRUD methods plus resource-specific extra actions.  The five curated resources are:</p> Attribute Resource class Model <code>client.contacts</code> <code>ContactsResource</code> <code>Contact</code> <code>client.companies</code> <code>CompaniesResource</code> <code>Company</code> <code>client.deals</code> <code>DealsResource</code> <code>Deal</code> <code>client.invoices</code> <code>InvoicesResource</code> <code>Invoice</code> <code>client.quotations</code> <code>QuotationsResource</code> <code>Quotation</code>"},{"location":"guides/resources/#crud-methods","title":"CRUD methods","text":"<p>All five resources inherit from <code>CrudResource[M]</code> and expose:</p> <pre><code># List \u2014 returns a Page[M] (see Pagination below)\npage = client.contacts.list(page=1, page_size=20, filter={\"email\": \"x@y.com\"})\n\n# Get a single object by UUID\ncontact = client.contacts.get(\"cde0bc5f-8602-4e12-b5d3-f03436b54c0d\")\n\n# Create \u2014 POSTs to contacts.add, re-fetches full object via contacts.info\ncontact = client.contacts.create(\n    first_name=\"Ada\",\n    last_name=\"Lovelace\",\n    emails=[{\"type\": \"primary\", \"email\": \"ada@example.com\"}],\n)\n\n# Update \u2014 POSTs to contacts.update, re-fetches via contacts.info\ncontact = client.contacts.update(\n    \"cde0bc5f-8602-4e12-b5d3-f03436b54c0d\",\n    last_name=\"Lovelace-King\",\n)\n\n# Delete\nclient.contacts.delete(\"cde0bc5f-8602-4e12-b5d3-f03436b54c0d\")\n</code></pre> <p>create() and update() always re-fetch</p> <p>Both methods re-fetch the full object via <code>.info</code> after the write so the returned model always reflects the server state (computed fields, defaults, etc.).</p>"},{"location":"guides/resources/#pagination","title":"Pagination","text":"<p><code>list()</code> returns a <code>Page[M]</code> dataclass:</p> Attribute Type Description <code>data</code> <code>list[M]</code> Deserialised model objects on this page <code>total_count</code> <code>int</code> Total matches across all pages <code>current_page</code> <code>int</code> 1-based page index <code>page_size</code> <code>int</code> Items requested per page <code>has_next</code> <code>bool</code> <code>True</code> when more pages exist"},{"location":"guides/resources/#manual-pagination","title":"Manual pagination","text":"<pre><code>page = client.deals.list(page=1, page_size=20, filter={\"status\": \"open\"})\n\nwhile True:\n    for deal in page.data:\n        print(deal.title, deal.status)\n    if not page.has_next:\n        break\n    page = page.next()\n</code></pre>"},{"location":"guides/resources/#iterate-consume-all-pages-automatically","title":"<code>iterate()</code> \u2014 consume all pages automatically","text":"<pre><code># iterate() uses page_size=20 by default; all extra kwargs are forwarded as filters\nfor contact in client.contacts.iterate(filter={\"tag\": \"vip\"}):\n    print(contact.full_name, contact.primary_email)\n</code></pre> <p><code>iterate()</code> is a generator that fetches pages lazily.  Wrap it with <code>itertools.islice</code> to cap the number of objects without loading all pages:</p> <pre><code>from itertools import islice\n\n# First 100 contacts only\ntop_100 = list(islice(client.contacts.iterate(), 100))\n</code></pre>"},{"location":"guides/resources/#extra-resource-methods","title":"Extra resource methods","text":""},{"location":"guides/resources/#contacts","title":"Contacts","text":"<pre><code># Add / remove tags (silently ignored if already present / absent)\nclient.contacts.tag(contact_id, [\"vip\", \"expo-2025\"])\nclient.contacts.untag(contact_id, [\"expo-2025\"])\n\n# Link / unlink a company (position and decision_maker are optional)\nclient.contacts.link_to_company(\n    contact_id,\n    company_id,\n    position=\"CTO\",\n    decision_maker=True,\n)\nclient.contacts.unlink_from_company(contact_id, company_id)\n</code></pre>"},{"location":"guides/resources/#companies","title":"Companies","text":"<pre><code>client.companies.tag(company_id, [\"customer\", \"enterprise\"])\nclient.companies.untag(company_id, [\"prospect\"])\n</code></pre>"},{"location":"guides/resources/#deals","title":"Deals","text":"<pre><code># Move a deal to a different pipeline phase\nclient.deals.move_to_phase(deal_id, phase_id)\n\n# Mark as won or lost\nclient.deals.win(deal_id)\nclient.deals.lose(deal_id, reason_id=\"reason-uuid\", extra_info=\"Too expensive\")\n\n# List available phases for a pipeline\nphases = client.deals.list_phases(deal_pipeline_id=\"pipeline-uuid\")\n\n# List all deal sources\nsources = client.deals.list_sources()\n</code></pre>"},{"location":"guides/resources/#invoices","title":"Invoices","text":"<pre><code># Book a draft invoice (transitions it from draft \u2192 booked)\nclient.invoices.book(invoice_id, on=\"2025-03-01\")\n\n# Credit an invoice \u2014 returns a TypeAndId referencing the new credit note\ncredit_note_ref = client.invoices.credit(invoice_id, credit_note_date=\"2025-03-05\")\n\n# Register a payment\nfrom teamleader.models import Money\nclient.invoices.register_payment(\n    invoice_id,\n    payment=Money(amount=500.0, currency=\"EUR\"),\n    paid_at=\"2025-03-01T12:00:00+00:00\",\n)\n\n# Send via e-mail\nclient.invoices.send(\n    invoice_id,\n    subject=\"Your invoice #2025-042\",\n    body=\"Please find your invoice attached.\",\n)\n\n# Get a pre-signed download URL\n# Returns {\"location\": \"&lt;url&gt;\", \"expires\": \"&lt;ISO datetime&gt;\"}\ndownload = client.invoices.download(invoice_id, format=\"pdf\")\nprint(download[\"location\"])\n</code></pre>"},{"location":"guides/resources/#quotations","title":"Quotations","text":"<pre><code># Send one or more quotations from the same deal\nclient.quotations.send(\n    quotation_ids=[\"q-uuid-1\"],\n    recipients={\"to\": [{\"email_address\": \"client@example.com\"}]},\n    subject=\"Quotation for your project\",\n    content=\"Please find your quotation attached.\",\n    language=\"en\",\n)\n\n# Mark a quotation as accepted\nclient.quotations.accept(quotation_id)\n</code></pre>"},{"location":"guides/resources/#filter-kwargs","title":"Filter kwargs","text":"<p>Filters are forwarded verbatim as the <code>filter</code> key in the POST body.  The available filter fields per endpoint are documented in the Generated Endpoint Reference.</p> <pre><code># Filter contacts by tag\npage = client.contacts.list(filter={\"tag\": \"vip\"})\n\n# Filter open deals assigned to a specific user\npage = client.deals.list(filter={\"status\": [\"open\"], \"assignee_id\": user_uuid})\n</code></pre>"}]}